OBJECT Table 50000 Excel Buffer Extended
{
  OBJECT-PROPERTIES
  {
    Date=14.12.23;
    Time=13:15:54;
    Modified=Yes;
    Version List=;
  }
  PROPERTIES
  {
    CaptionML=[DEU=Excelpuffer Erweitert;
               ENU=Excel Buffer Extended];
  }
  FIELDS
  {
    { 1   ;   ;Row No.             ;Integer       ;OnValidate=BEGIN
                                                                xlRowID := '';
                                                                IF "Row No." <> 0 THEN
                                                                  xlRowID := FORMAT("Row No.");
                                                              END;

                                                   DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Zeilennr.;
                                                              ENU=Row No.] }
    { 2   ;   ;xlRowID             ;Text10        ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=XlZeileID;
                                                              ENU=xlRowID] }
    { 3   ;   ;Column No.          ;Integer       ;OnValidate=VAR
                                                                x@1000 : Integer;
                                                                i@1001 : Integer;
                                                                y@1003 : Integer;
                                                                c@1002 : Char;
                                                                t@1102601000 : Text[30];
                                                              BEGIN
                                                                xlColID := '';
                                                                x := "Column No.";
                                                                WHILE x > 26 DO BEGIN
                                                                  y := x MOD 26;
                                                                  IF y = 0 THEN
                                                                    y := 26;
                                                                  c := 64 + y;
                                                                  i := i + 1;
                                                                  t[i] := c;
                                                                  x := (x - y) DIV 26;
                                                                END;
                                                                IF x > 0 THEN BEGIN
                                                                  c := 64 + x;
                                                                  i := i + 1;
                                                                  t[i] := c;
                                                                END;
                                                                FOR x := 1 TO i DO
                                                                  xlColID[x] := t[1 + i - x];
                                                              END;

                                                   DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Spaltennr.;
                                                              ENU=Column No.] }
    { 4   ;   ;xlColID             ;Text10        ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=XlSpalteID;
                                                              ENU=xlColID] }
    { 5   ;   ;Cell Value as Text  ;Text250       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Zellenwert als Text;
                                                              ENU=Cell Value as Text] }
    { 6   ;   ;Comment             ;Text250       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Bemerkung;
                                                              ENU=Comment] }
    { 7   ;   ;Formula             ;Text250       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Formel;
                                                              ENU=Formula] }
    { 8   ;   ;Bold                ;Boolean       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Fett;
                                                              ENU=Bold] }
    { 9   ;   ;Italic              ;Boolean       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Kursiv;
                                                              ENU=Italic] }
    { 10  ;   ;Underline           ;Boolean       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Unterstrichen;
                                                              ENU=Underline] }
    { 11  ;   ;NumberFormat        ;Text30        ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Nummernformat;
                                                              ENU=NumberFormat] }
    { 12  ;   ;Formula2            ;Text250       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Formel 2;
                                                              ENU=Formula2] }
    { 13  ;   ;Formula3            ;Text250       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Formel 3;
                                                              ENU=Formula3] }
    { 14  ;   ;Formula4            ;Text250       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Formel 4;
                                                              ENU=Formula4] }
    { 15  ;   ;Cell Type           ;Option        ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Zellentyp;
                                                              ENU=Cell Type];
                                                   OptionCaptionML=[DEU=Nummer,Text,Datum,Uhrzeit;
                                                                    ENU=Number,Text,Date,Time];
                                                   OptionString=Number,Text,Date,Time }
    { 16  ;   ;Double Underline    ;Boolean       ;DataClassification=SystemMetadata;
                                                   CaptionML=[DEU=Doppelt unterstrichen;
                                                              ENU=Double Underline] }
    { 20  ;   ;Font Name           ;Text30        ;CaptionML=ENU=Font Name }
    { 21  ;   ;Font Size           ;Integer       ;CaptionML=ENU=Font Size }
    { 22  ;   ;Font Color          ;Text10        ;CaptionML=ENU=Font Color }
    { 23  ;   ;Background Color    ;Text10        ;CaptionML=ENU=Background Color }
    { 28  ;   ;Border Style        ;Option        ;CaptionML=ENU=Border Style;
                                                   OptionCaptionML=ENU=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot;
                                                   OptionString=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot }
    { 29  ;   ;Border Color        ;Text10        ;CaptionML=ENU=Border Color }
    { 30  ;   ;Left Border Style   ;Option        ;CaptionML=ENU=Left Border Style;
                                                   OptionCaptionML=ENU=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot;
                                                   OptionString=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot }
    { 31  ;   ;Left Border Color   ;Text10        ;CaptionML=ENU=Left Border Color }
    { 32  ;   ;Right Border Style  ;Option        ;CaptionML=ENU=Right Border Style;
                                                   OptionCaptionML=ENU=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot;
                                                   OptionString=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot }
    { 33  ;   ;Right Border Color  ;Text10        ;CaptionML=ENU=Right Border Color }
    { 34  ;   ;Top Border Style    ;Option        ;CaptionML=ENU=Top Border Style;
                                                   OptionCaptionML=ENU=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot;
                                                   OptionString=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot }
    { 35  ;   ;Top Border Color    ;Text10        ;CaptionML=ENU=Top Border Color }
    { 36  ;   ;Bottom Border Style ;Option        ;CaptionML=ENU=Bottom Border Style;
                                                   OptionCaptionML=ENU=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot;
                                                   OptionString=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot }
    { 37  ;   ;Bottom Border Color ;Text10        ;CaptionML=ENU=Bottom Border Color }
    { 38  ;   ;Diagonal Border Style;Option       ;CaptionML=ENU=Diagonal Border Style;
                                                   OptionCaptionML=ENU=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot;
                                                   OptionString=None,Thin,Medium,Dashed,Dotted,Thick,Double,Hair,MediumDashed,DashDot,MediumDashDot,DashDotDot,MediumDashDotDot,SlantDashDot }
    { 39  ;   ;Diagonal Border Color;Text10       ;CaptionML=ENU=Diagonal Border Color }
    { 50  ;   ;Horizontal Alignment;Option        ;CaptionML=ENU=Horizontal Alignment;
                                                   OptionCaptionML=ENU=Automatic,Left,Center,Right,Fill,Justify,CenterAcrossSelection,Distributed,JustifyDistributed;
                                                   OptionString=Automatic,Left,Center,Right,Fill,Justify,CenterAcrossSelection,Distributed,JustifyDistributed }
    { 51  ;   ;Vertical Alignment  ;Option        ;CaptionML=ENU=Vertical Alignment;
                                                   OptionCaptionML=ENU=Automatic,Top,Center,Bottom,Justify,Distributed,JustifyDistributed;
                                                   OptionString=Automatic,Top,Center,Bottom,Justify,Distributed,JustifyDistributed }
    { 52  ;   ;Indent              ;Integer       ;CaptionML=ENU=Indent }
    { 53  ;   ;Reading Order       ;Option        ;CaptionML=ENU=Reading Order;
                                                   OptionCaptionML=ENU=Context,Left-to-Right,Right-to-Left;
                                                   OptionString=Context,Left-to-Right,Right-to-Left }
    { 54  ;   ;Relative Indent     ;Integer       ;CaptionML=ENU=Relative Indent }
    { 55  ;   ;Shrink To Fit       ;Boolean       ;CaptionML=ENU=Shrink To Fit }
    { 56  ;   ;Text Rotation       ;Integer       ;CaptionML=ENU=Text Rotation }
    { 57  ;   ;Wrap Text           ;Boolean       ;CaptionML=ENU=Wrap Text }
    { 58  ;   ;Justify Last Line   ;Boolean       ;CaptionML=ENU=Justify Last Line }
    { 70  ;   ;Unlocked            ;Boolean       ;DataClassification=ToBeClassified;
                                                   CaptionML=ENU=Unlocked }
    { 71  ;   ;Formula Hidden      ;Boolean       ;DataClassification=ToBeClassified;
                                                   CaptionML=ENU=Formula Hidden }
    { 100 ;   ;Width               ;Integer       ;CaptionML=ENU=Width }
    { 101 ;   ;Height              ;Integer       ;CaptionML=ENU=Height }
    { 102 ;   ;Hidden              ;Boolean       ;CaptionML=ENU=Hidden }
    { 103 ;   ;Outline Level       ;Integer       ;CaptionML=ENU=Outline Level }
    { 104 ;   ;Collapsed           ;Boolean       ;DataClassification=ToBeClassified;
                                                   CaptionML=ENU=Collapsed }
    { 1000;   ;Color               ;Option        ;FieldClass=FlowFilter;
                                                   CaptionML=ENU=Color;
                                                   OptionCaptionML=ENU=Black,White,Dark Red,Red,Orange,Yellow,Light Green,Green,Light Blue,Blue,Dark Blue,Purple;
                                                   OptionString=Black,White,Dark Red,Red,Orange,Yellow,Light Green,Green,Light Blue,Blue,Dark Blue,Purple }
    { 1001;   ;Property            ;Option        ;FieldClass=FlowFilter;
                                                   CaptionML=ENU=Property;
                                                   OptionCaptionML=ENU=Width,Height,Outline Level,Hidden,Collapsed;
                                                   OptionString=Width,Height,Outline Level,Hidden,Collapsed }
    { 1002;   ;Fit To Page         ;Option        ;FieldClass=FlowFilter;
                                                   CaptionML=ENU=Fit To Page;
                                                   OptionCaptionML=ENU=NoScale,Sheet,Columns,Rows;
                                                   OptionString=NoScale,Sheet,Columns,Rows }
  }
  KEYS
  {
    {    ;Row No.,Column No.                      ;Clustered=Yes }
  }
  FIELDGROUPS
  {
  }
  CODE
  {
    VAR
      Text000@1000 : TextConst '@@@="{Locked=""Excel""}";DEU=Excel wurde nicht gefunden.;ENU=Excel not found.';
      Text001@1001 : TextConst 'DEU=Sie mssen einen Dateinamen angeben.;ENU=You must enter a file name.';
      Text002@1002 : TextConst '@@@="{Locked=""Excel""}";DEU=Sie mssen einen Exceltabellennamen angeben.;ENU=You must enter an Excel worksheet name.';
      Text003@1003 : TextConst 'DEU=Die Datei %1 ist nicht vorhanden.;ENU=The file %1 does not exist.';
      Text004@1004 : TextConst '@@@="{Locked=""Excel""}";DEU=Die Exceltabelle %1 ist nicht vorhanden.;ENU=The Excel worksheet %1 does not exist.';
      Text005@1005 : TextConst '@@@="{Locked=""Excel""}";DEU=Excel-Arbeitsbl. erstellen...\\;ENU=Creating Excel worksheet...\\';
      PageTxt@1006 : TextConst 'DEU=Seite;ENU=Page';
      Text007@1007 : TextConst '@@@="{Locked=""Excel""}";DEU=Excel-Arbeitsbl. lesen...\\;ENU=Reading Excel worksheet...\\';
      Text013@1013 : TextConst 'DEU=&B;ENU=&B';
      Text014@1014 : TextConst 'DEU=&D;ENU=&D';
      Text015@1015 : TextConst 'DEU=&P;ENU=&P';
      Text016@1016 : TextConst 'DEU=A1;ENU=A1';
      Text017@1017 : TextConst 'DEU=SUMIF;ENU=SUMIF';
      Text018@1018 : TextConst 'DEU=#N/A;ENU=#N/A';
      Text019@1019 : TextConst '@@@={Locked} Used to define an Excel range name. You must refer to Excel rules to change this term.;DEU=GLAcc;ENU=GLAcc';
      Text020@1020 : TextConst '@@@={Locked} Used to define an Excel range name. You must refer to Excel rules to change this term.;DEU=Period;ENU=Period';
      Text021@1021 : TextConst 'DEU=Budget;ENU=Budget';
      TempInfoExcelBuf@1036 : TEMPORARY Record 50000;
      TempColumnsExcelBuf@1000000008 : TEMPORARY Record 50000;
      TempRowsExcelBuf@1000000006 : TEMPORARY Record 50000;
      TempImageExcelBuf@1000000009 : TEMPORARY Record 50000;
      TempDefaultsExcelBuf@1000000028 : TEMPORARY Record 50000;
      FileManagement@1045 : Codeunit 419;
      XMLDOMManagement@1000000001 : Codeunit 6224;
      XlWrkBkWriter@1022 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.WorkbookWriter";
      XlWrkBkReader@1023 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.WorkbookReader";
      XlWrkShtWriter@1024 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.WorksheetWriter";
      XlWrkShtReader@1043 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.WorksheetReader";
      XlApp@1044 : DotNet "'Microsoft.Office.Interop.Excel, Version=15.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c'.Microsoft.Office.Interop.Excel.ApplicationClass" RUNONCLIENT;
      XlWrkBk@1051 : DotNet "'Microsoft.Office.Interop.Excel, Version=15.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c'.Microsoft.Office.Interop.Excel.Workbook" RUNONCLIENT;
      XlWrkSht@1009 : DotNet "'Microsoft.Office.Interop.Excel, Version=15.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c'.Microsoft.Office.Interop.Excel.Worksheet" RUNONCLIENT;
      XlHelper@1052 : DotNet "'Microsoft.Dynamics.Nav.Integration.Office, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.Integration.Office.Excel.ExcelHelper" RUNONCLIENT;
      VmlDrawingPart@1000000012 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.VmlDrawingPart";
      PivotTablePart@1000000037 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.PivotTablePart";
      XmlWrkShtDoc@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlDocument";
      XmlCellFormatsDoc@1000000002 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlDocument";
      MergedCellsList@1119429001 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Collections.Generic.List`1";
      StringBld@1000000013 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";
      OpenXmlStringValue@1101495002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.StringValue";
      OpenXmlUInt32Value@1101495001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.UInt32Value";
      OpenXmlBoolValue@1101495000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.BooleanValue";
      XlSheetProtection@1000000014 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.SheetProtection";
      ActiveSheetName@1049 : Text[250];
      RangeStartXlRow@1034 : Text[30];
      RangeStartXlCol@1033 : Text[30];
      RangeEndXlRow@1032 : Text[30];
      RangeEndXlCol@1031 : Text[30];
      FileNameServer@1046 : Text;
      FriendlyName@1025 : Text;
      ClientPath@1000000032 : Text;
      TabColorText@1000000015 : Text[20];
      CurrentRow@1029 : Integer;
      CurrentCol@1030 : Integer;
      FirstCustomStyleID@1000000003 : Integer;
      UseInfoSheet@1035 : Boolean;
      Text022@1041 : TextConst '@@@={Locked} Used to define an Excel range name. You must refer to Excel rules to change this term.;DEU=CostAcc;ENU=CostAcc';
      Text023@1037 : TextConst 'DEU=Informationen;ENU=Information';
      Text034@1039 : TextConst '@@@="{Split=r''\|\*\..{1,4}\|?''}{Locked=""Excel""}";DEU=Excel-Dateien (*.xls*)|*.xls*|Alle Dateien (*.*)|*.*;ENU=Excel Files (*.xls*)|*.xls*|All Files (*.*)|*.*';
      Text035@1040 : TextConst 'DEU=Der Vorgang wurde abgebrochen.;ENU=The operation was canceled.';
      Text036@1042 : TextConst '@@@="{Locked=""Excel""}";DEU=Die Excel-Tabelle ist nicht vorhanden.;ENU=The Excel workbook does not exist.';
      Text037@1047 : TextConst '@@@="{Locked=""Excel""}";DEU=Die Excel-Tabelle konnte nicht erstellt werden.;ENU=Could not create the Excel workbook.';
      Text038@1048 : TextConst 'DEU=Die globale Variable ''%1'' ist nicht fr den Test enthalten.;ENU=Global variable %1 is not included for test.';
      Text039@1050 : TextConst 'DEU=Die Zellenart wurde nicht definiert.;ENU=Cell type has not been set.';
      Text040@1008 : TextConst '@@@="{Locked=""Excel""}";DEU=Excel-Datei exportieren;ENU=Export Excel File';
      SavingDocumentMsg@1010 : TextConst 'DEU=Das folgende Dokument wird gespeichert: %1.;ENU=Saving the following document: %1.';
      ExcelFileExtensionTok@1012 : TextConst '@@@={Locked};DEU=.xlsx;ENU=.xlsx';
      SkipAutoFit@1055 : Boolean;
      HideDialog@1119429000 : Boolean;
      UseCustomColumns@1000000004 : Boolean;
      SummaryColumnsToLeft@1000000007 : Boolean;
      SummaryRowsAbove@1000000005 : Boolean;

      CommentVmlShapeXmlTxt@1000000011 : TextConst
        '@@@={Locked}',
        'DEU="<v:shape id=""%1"" type=""#_x0000_t202"" style=''position:absolute;  margin-left:59.25pt;margin-top:1.5pt;width:96pt;height:55.5pt;z-index:1;  visibility:hidden'' fillcolor=""#ffffe1"" o:insetmode=""auto""><v:fill color2=""#ffffe1""/><v:shadow color=""black"" obscured=""t""/><v:path o:connecttype=""none""/><v:textbox style=''mso-direction-alt:auto''><div style=''text-align:left''/></v:textbox><x:ClientData ObjectType=""Note""><x:MoveWithCells/><x:SizeWithCells/><x:Anchor>%2</x:Anchor><x:AutoFill>False</x:AutoFill><x:Row>%3</x:Row><x:Column>%4</x:Column></x:ClientData></v:shape>"',
        'ENU="<v:shape id=""%1"" type=""#_x0000_t202"" style=''position:absolute;margin-left:59.25pt;margin-top:1.5pt;width:96pt;height:55.5pt;z-index:1;visibility:hidden;mso-wrap-style:tight'' fillcolor=""#ffffe1"" o:insetmode=""auto""><v:fill color2=""#ffffe1""/><v:shadow color=""black"" obscured=""t""/><v:path o:connecttype=""none""/><v:textbox style=''mso-direction-alt:auto''><div style=''text-align:left''/></v:textbox><x:ClientData ObjectType=""Note""><x:MoveWithCells/><x:SizeWithCells/><x:Anchor>%2</x:Anchor><x:AutoFill>False</x:AutoFill><x:Row>%3</x:Row><x:Column>%4</x:Column></x:ClientData></v:shape>"';
      VmlShapeAnchorTxt@1000000010 : TextConst '@@@={Locked};DEU=%1,15,%2,10,%3,31,8,9;ENU=%1,15,%2,10,%3,31,8,9';
      AutoFilterRange@1000000016 : Text;
      FreezePaneRowNo@1000000017 : Integer;
      FreezePaneColNo@1000000018 : Integer;
      PortraitOrientation@1000000019 : Boolean;
      FitToPageMode@1000000020 : 'NoScale,Sheet,Columns,Rows';
      CustomPageMargins@1000000021 : Boolean;
      LeftMargin@1000000022 : Decimal;
      RightMargin@1000000023 : Decimal;
      TopMargin@1000000024 : Decimal;
      BottomMargin@1000000025 : Decimal;
      HeaderMargin@1000000026 : Decimal;
      FooterMargin@1000000027 : Decimal;
      CurrSheetID@1000000029 : Integer;
      ActiveSheetID@1000000030 : Integer;
      PathDoesNotExistErr@1000000031 : TextConst 'DEU=Der Pfad "%1" ist nicht vorhanden.;ENU=The path %1 does not exist.';
      InvalidValueErr@1000000033 : TextConst 'DEU=Der Parameter ''%1'' hat einen ungltigen Wert.;ENU=The parameter ''%1'' has invalid value %2.';
      InvalidColumnCodeErr@1000000034 : TextConst 'DEU=%1 ist ungltiger Spaltencode.;ENU=%1 is invalid Column Code.';
      InvalidCellAddrErr@1000000035 : TextConst 'DEU=%1 ist ungltiger Zellenadresse.;ENU=%1 is invalid cell address.';
      InvalidRangeErr@1000000036 : TextConst 'DEU=%1 ist ungltiger Bereich.;ENU=%1 is invalid range.';
      PivotFieldDoesntExistErr@1000000038 : TextConst 'DEU=Pivot Field %1 ist nicht vorhanden.;ENU=Pivot Field %1 does not exist.';
      NoSubtotalFuncErr@1000000039 : TextConst 'DEU=Sie mssen die subtotal funktion fr das Feld %1 angeben.;ENU=You must specify subtotal function for %1 field.';
      PaperSize@1011 : Integer;

    PROCEDURE CreateBook@1(FileName@1001 : Text;SheetName@1000 : Text[250]);
    BEGIN
      IF SheetName = '' THEN
        ERROR(Text002);

      IF FileName = '' THEN
        FileNameServer := FileManagement.ServerTempFileName('xlsx')
      ELSE BEGIN
        IF EXISTS(FileName) THEN
          ERASE(FileName);
        FileNameServer := FileName;
      END;

      XlWrkBkWriter := XlWrkBkWriter.Create(FileNameServer);
      IF ISNULL(XlWrkBkWriter) THEN
        ERROR(Text037);

      XlWrkShtWriter := XlWrkBkWriter.FirstWorksheet;
      IF SheetName <> '' THEN BEGIN
        XlWrkShtWriter.Name := SheetName;
        ActiveSheetName := SheetName;
      END;

      UseCustomColumns := FALSE;
      CurrSheetID := 0;
    END;

    PROCEDURE OpenBook@2(FileName@1000 : Text;SheetName@1001 : Text[250]);
    BEGIN
      IF FileName = '' THEN
        ERROR(Text001);

      IF SheetName = '' THEN
        ERROR(Text002);

      IF SheetName = 'G/L Account' THEN
        SheetName := 'GL Account';

      XlWrkBkReader := XlWrkBkReader.Open(FileName);
      IF XlWrkBkReader.HasWorksheet(SheetName) THEN BEGIN
        XlWrkShtReader := XlWrkBkReader.GetWorksheetByName(SheetName);
      END ELSE BEGIN
        QuitExcel;
        ERROR(Text004,SheetName);
      END;
    END;

    PROCEDURE OpenBookStream@44(FileStream@1000 : InStream;SheetName@1001 : Text) : Text;
    BEGIN
      IF SheetName = '' THEN
        EXIT(Text002);

      IF SheetName = 'G/L Account' THEN
        SheetName := 'GL Account';

      XlWrkBkReader := XlWrkBkReader.Open(FileStream);
      IF XlWrkBkReader.HasWorksheet(SheetName) THEN
        XlWrkShtReader := XlWrkBkReader.GetWorksheetByName(SheetName)
      ELSE BEGIN
        QuitExcel;
        ERROR(Text004,SheetName);
      END;
    END;

    PROCEDURE UpdateBook@5(FileName@1000 : Text;SheetName@1001 : Text[250]);
    BEGIN
      UpdateBookExcel(FileName,SheetName,TRUE);
    END;

    PROCEDURE UpdateBookExcel@48(FileName@1001 : Text;SheetName@1000 : Text[250];PreserveDataOnUpdate@1002 : Boolean);
    BEGIN
      IF FileName = '' THEN
        ERROR(Text001);

      IF SheetName = '' THEN
        ERROR(Text002);

      FileNameServer := FileName;
      XlWrkBkWriter := XlWrkBkWriter.Open(FileNameServer);
      IF XlWrkBkWriter.HasWorksheet(SheetName) THEN BEGIN
        XlWrkShtWriter := XlWrkBkWriter.GetWorksheetByName(SheetName);
        // Set PreserverDataOnUpdate to false if the sheet writer should clear all empty cells
        // in which NAV does not have new data. Notice that the sheet writer will only clear Excel
        // cells that are addressed by the writer. All other cells will be left unmodified.
        XlWrkShtWriter.PreserveDataOnUpdate := PreserveDataOnUpdate;
        ActiveSheetName := SheetName;
      END ELSE BEGIN
        QuitExcel;
        ERROR(Text004,SheetName);
      END;
    END;

    PROCEDURE CloseBook@30();
    BEGIN
      IF NOT ISNULL(XlWrkBkWriter) THEN BEGIN
        SetActiveSheet;
        XlWrkBkWriter.ClearFormulaCalculations;
        XlWrkBkWriter.ValidateDocument;
        XlWrkBkWriter.Close;
        CLEAR(XlWrkShtWriter);
        CLEAR(XlWrkBkWriter);
      END;

      IF NOT ISNULL(XlWrkBkReader) THEN BEGIN
        CLEAR(XlWrkShtReader);
        CLEAR(XlWrkBkReader);
      END;
    END;

    PROCEDURE WriteSheet@37(ReportHeader@1001 : Text;CompanyName2@1002 : Text;UserID2@1003 : Text);
    VAR
      ExcelBufferDialogMgt@1009 : Codeunit 5370;
      CRLF@1008 : Char;
      RecNo@1010 : Integer;
      InfoRecNo@1012 : Integer;
      TotalRecNo@1011 : Integer;
      LastUpdate@1004 : DateTime;
      CreateCustomStyles@1000000000 : Boolean;
    BEGIN
      LastUpdate := CURRENTDATETIME;
      IF NOT HideDialog THEN
        ExcelBufferDialogMgt.Open(Text005);

      CRLF := 10;
      RecNo := 1;
      TotalRecNo := COUNT + TempInfoExcelBuf.COUNT;
      RecNo := 0;
      CurrSheetID += 1;

      WriteColumnsProperties;
      WriteSheetProtection;
      WriteSheetViews;
      WriteSheetProperties;
      WriteAutoFilter;
      WriteMergedCells;
      WritePageSetup;

      AddEmptyRows();

      IF FINDSET THEN
        REPEAT
          RecNo := RecNo + 1;
          IF NOT HideDialog THEN
            IF NOT UpdateProgressDialog(ExcelBufferDialogMgt,LastUpdate,RecNo,TotalRecNo) THEN BEGIN
              QuitExcel;
              ERROR(Text035)
            END;
          IF Formula = '' THEN
            WriteCellValue(Rec)
          ELSE
            WriteCellFormula(Rec);
          IF Comment <> '' THEN
            SetCellComment("Column No.", "Row No.", Comment);
          IF HasCustomStyle THEN BEGIN
            CreateCustomStyles := TRUE;
            TotalRecNo += 1;
          END;
        UNTIL NEXT = 0;

      IF ReportHeader <> '' THEN
        XlWrkShtWriter.AddHeader(
          TRUE,
          STRSUBSTNO('%1%2%1%3%4',GetExcelReference(1),ReportHeader,CRLF,CompanyName2));

      XlWrkShtWriter.AddHeader(
        FALSE,
        STRSUBSTNO('%1%3%4%3%5 %2',GetExcelReference(2),GetExcelReference(3),CRLF,UserID2,PageTxt));

      WriteRowsProperties;
      IF CreateCustomStyles THEN
        WriteAlignment(ExcelBufferDialogMgt,LastUpdate,RecNo,TotalRecNo);
      WriteImages;
      FinishVmlDrawingPart;

      IF UseInfoSheet THEN
        IF TempInfoExcelBuf.FINDSET THEN BEGIN
          XlWrkShtWriter := XlWrkBkWriter.AddWorksheet(Text023);
          REPEAT
            InfoRecNo := InfoRecNo + 1;
            IF NOT UpdateProgressDialog(ExcelBufferDialogMgt,LastUpdate,RecNo + InfoRecNo,TotalRecNo) THEN BEGIN
              QuitExcel;
              ERROR(Text035)
            END;
            IF TempInfoExcelBuf.Formula = '' THEN
              WriteCellValue(TempInfoExcelBuf)
            ELSE
              WriteCellFormula(TempInfoExcelBuf)
          UNTIL TempInfoExcelBuf.NEXT = 0;
        END;

      IF NOT HideDialog THEN
        ExcelBufferDialogMgt.Close;
    END;

    LOCAL PROCEDURE WriteCellValue@28(ExcelBuffer@1000 : Record 50000);
    VAR
      Decorator@1001 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.CellDecorator";
    BEGIN
      WITH ExcelBuffer DO BEGIN
        GetCellDecorator(ExcelBuffer, Decorator);

        CASE "Cell Type" OF
          "Cell Type"::Number:
            XlWrkShtWriter.SetCellValueNumber("Row No.",xlColID,"Cell Value as Text",NumberFormat,Decorator);
          "Cell Type"::Text:
            XlWrkShtWriter.SetCellValueText("Row No.",xlColID,"Cell Value as Text",Decorator);
          "Cell Type"::Date:
            XlWrkShtWriter.SetCellValueDate("Row No.",xlColID,"Cell Value as Text",NumberFormat,Decorator);
          "Cell Type"::Time:
            XlWrkShtWriter.SetCellValueTime("Row No.",xlColID,"Cell Value as Text",NumberFormat,Decorator);
          ELSE
            ERROR(Text039)
        END;
      END;
    END;

    LOCAL PROCEDURE WriteCellFormula@38(ExcelBuffer@1000 : Record 50000);
    VAR
      Decorator@1001 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.CellDecorator";
    BEGIN
      WITH ExcelBuffer DO BEGIN
        GetCellDecorator(ExcelBuffer, Decorator);

        XlWrkShtWriter.SetCellFormula("Row No.",xlColID,GetFormula,NumberFormat,Decorator);
      END;
    END;

    PROCEDURE CreateRangeName@9(RangeName@1000 : Text[30];FromColumnNo@1001 : Integer;FromRowNo@1002 : Integer);
    VAR
      TempExcelBuf@1005 : TEMPORARY Record 370;
      ToxlRowID@1004 : Text[10];
    BEGIN
      SETCURRENTKEY("Row No.","Column No.");
      IF FIND('+') THEN
        ToxlRowID := xlRowID;
      TempExcelBuf.VALIDATE("Row No.",FromRowNo);
      TempExcelBuf.VALIDATE("Column No.",FromColumnNo);

      AddDefinedName(
        RangeName,
        1,
        GetExcelReference(4) + TempExcelBuf.xlColID + GetExcelReference(4) + TempExcelBuf.xlRowID +
        ':' +
        GetExcelReference(4) + TempExcelBuf.xlColID + GetExcelReference(4) + ToxlRowID);
    END;

    PROCEDURE GiveUserControl@3();
    BEGIN
      IF NOT ISNULL(XlApp) THEN BEGIN
        XlApp.Visible := TRUE;
        XlApp.UserControl := TRUE;
        CLEAR(XlApp);
      END;
    END;

    PROCEDURE ReadSheet@4();
    VAR
      ExcelBufferDialogMgt@1003 : Codeunit 5370;
      CellData@1002 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.CellData";
      Enumerator@1001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Collections.IEnumerator";
      RowCount@1009 : Integer;
      LastUpdate@1004 : DateTime;
    BEGIN
      LastUpdate := CURRENTDATETIME;
      IF NOT HideDialog THEN
        ExcelBufferDialogMgt.Open(Text007);
      DELETEALL;

      Enumerator := XlWrkShtReader.GetEnumerator;
      RowCount := XlWrkShtReader.RowCount;
      WHILE Enumerator.MoveNext DO BEGIN
        CellData := Enumerator.Current;
        IF CellData.HasValue THEN BEGIN
          VALIDATE("Row No.",CellData.RowNumber);
          VALIDATE("Column No.",CellData.ColumnNumber);
          ParseCellValue(CellData.Value,CellData.Format);
          INSERT;
          IF NOT HideDialog THEN
            IF NOT UpdateProgressDialog(ExcelBufferDialogMgt,LastUpdate,CellData.RowNumber,RowCount) THEN BEGIN
              QuitExcel;
              ERROR(Text035)
            END;
        END;
      END;

      QuitExcel;
      IF NOT HideDialog THEN
        ExcelBufferDialogMgt.Close;
    END;

    LOCAL PROCEDURE ParseCellValue@40(Value@1000 : Text;FormatString@1001 : Text);
    VAR
      Decimal@1004 : Decimal;
    BEGIN
      // The format contains only en-US number separators, this is an OpenXML standard requirement
      // The algorithm sieves the data based on formatting as follows (the steps must run in this order)
      // 1. FormatString = '@' -> Text
      // 2. FormatString.Contains(':') -> Time
      // 3. FormatString.ContainsOneOf('y', 'm', 'd') && FormatString.DoesNotContain('Red') -> Date
      // 4. anything else -> Decimal

      NumberFormat := COPYSTR(FormatString,1,30);

      IF FormatString = '@' THEN BEGIN
        "Cell Type" := "Cell Type"::Text;
        "Cell Value as Text" := Value;
        EXIT;
      END;

      EVALUATE(Decimal,Value);

      IF STRPOS(FormatString,':') <> 0 THEN BEGIN
        // Excel Time is stored in OADate format
        "Cell Type" := "Cell Type"::Time;
        "Cell Value as Text" := FORMAT(DT2TIME(ConvertDateTimeDecimalToDateTime(Decimal)));
        EXIT;
      END;

      IF ((STRPOS(FormatString,'y') <> 0) OR
          (STRPOS(FormatString,'m') <> 0) OR
          (STRPOS(FormatString,'d') <> 0)) AND
         (STRPOS(FormatString,'Red') = 0)
      THEN BEGIN
        "Cell Type" := "Cell Type"::Date;
        "Cell Value as Text" := FORMAT(DT2DATE(ConvertDateTimeDecimalToDateTime(Decimal)));
        EXIT;
      END;

      "Cell Type" := "Cell Type"::Number;
      "Cell Value as Text" := FORMAT(ROUND(Decimal,0.000001),0,1);
    END;

    PROCEDURE SelectSheetsName@6(FileName@1000 : Text) : Text[250];
    VAR
      TempNameValueBuffer@1009 : TEMPORARY Record 823;
      SheetNames@1008 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Collections.ArrayList";
      SheetName@1002 : Text[250];
      SelectedSheetName@1007 : Text[250];
      i@1001 : Integer;
    BEGIN
      IF FileName = '' THEN
        ERROR(Text001);

      XlWrkBkReader := XlWrkBkReader.Open(FileName);

      SelectedSheetName := '';
      SheetNames := SheetNames.ArrayList(XlWrkBkReader.SheetNames);
      IF NOT ISNULL(SheetNames) THEN BEGIN
        FOR i := 0 TO SheetNames.Count - 1 DO BEGIN
          SheetName := SheetNames.Item(i);
          IF SheetName <> '' THEN BEGIN
            TempNameValueBuffer.INIT;
            TempNameValueBuffer.ID := i;
            TempNameValueBuffer.Name := FORMAT(i + 1);
            TempNameValueBuffer.Value := SheetName;
            TempNameValueBuffer.INSERT;
          END;
        END;
        IF NOT TempNameValueBuffer.ISEMPTY THEN
          IF TempNameValueBuffer.COUNT = 1 THEN
            SelectedSheetName := TempNameValueBuffer.Value
          ELSE BEGIN
            TempNameValueBuffer.FINDFIRST;
            IF PAGE.RUNMODAL(PAGE::"Name/Value Lookup",TempNameValueBuffer) = ACTION::LookupOK THEN
              SelectedSheetName := TempNameValueBuffer.Value;
          END;
      END;

      QuitExcel;
      EXIT(SelectedSheetName);
    END;

    PROCEDURE GetExcelReference@10(Which@1000 : Integer) : Text[250];
    BEGIN
      CASE Which OF
        1:
          EXIT(Text013);
        // DO NOT TRANSLATE: &B is the Excel code to turn bold printing on or off for customized Header/Footer.
        2:
          EXIT(Text014);
        // DO NOT TRANSLATE: &D is the Excel code to print the current date in customized Header/Footer.
        3:
          EXIT(Text015);
        // DO NOT TRANSLATE: &P is the Excel code to print the page number in customized Header/Footer.
        4:
          EXIT('$');
        // DO NOT TRANSLATE: $ is the Excel code for absolute reference to cells.
        5:
          EXIT(Text016);
        // DO NOT TRANSLATE: A1 is the Excel reference of the first cell.
        6:
          EXIT(Text017);
        // DO NOT TRANSLATE: SUMIF is the name of the Excel function used to summarize values according to some conditions.
        7:
          EXIT(Text018);
        // DO NOT TRANSLATE: The #N/A Excel error value occurs when a value is not available to a function or formula.
        8:
          EXIT(Text019);
        // DO NOT TRANSLATE: GLAcc is used to define an Excel range name. You must refer to Excel rules to change this term.
        9:
          EXIT(Text020);
        // DO NOT TRANSLATE: Period is used to define an Excel range name. You must refer to Excel rules to change this term.
        10:
          EXIT(Text021);
        // DO NOT TRANSLATE: Budget is used to define an Excel worksheet name. You must refer to Excel rules to change this term.
        11:
          EXIT(Text022);
        // DO NOT TRANSLATE: CostAcc is used to define an Excel range name. You must refer to Excel rules to change this term.
      END;
    END;

    PROCEDURE ExportBudgetFilterToFormula@11(VAR ExcelBuf@1000 : Record 370) : Boolean;
    VAR
      TempExcelBufFormula@1001 : TEMPORARY Record 370;
      TempExcelBufFormula2@1004 : TEMPORARY Record 370;
      FirstRow@1002 : Integer;
      LastRow@1003 : Integer;
      HasFormulaError@1005 : Boolean;
      ThisCellHasFormulaError@1006 : Boolean;
    BEGIN
      ExcelBuf.SETFILTER(Formula,'<>%1','');
      IF ExcelBuf.FINDSET THEN
        REPEAT
          TempExcelBufFormula := ExcelBuf;
          TempExcelBufFormula.INSERT;
        UNTIL ExcelBuf.NEXT = 0;
      ExcelBuf.RESET;

      WITH TempExcelBufFormula DO
        IF FINDSET THEN
          REPEAT
            ThisCellHasFormulaError := FALSE;
            ExcelBuf.SETRANGE("Column No.",1);
            ExcelBuf.SETFILTER("Row No.",'<>%1',"Row No.");
            ExcelBuf.SETFILTER("Cell Value as Text",Formula);
            TempExcelBufFormula2 := TempExcelBufFormula;
            IF ExcelBuf.FINDSET THEN
              REPEAT
                IF NOT GET(ExcelBuf."Row No.","Column No.") THEN
                  ExcelBuf.MARK(TRUE);
              UNTIL ExcelBuf.NEXT = 0;
            TempExcelBufFormula := TempExcelBufFormula2;
            ClearFormula;
            ExcelBuf.SETRANGE("Cell Value as Text");
            ExcelBuf.SETRANGE("Row No.");
            IF ExcelBuf.FINDSET THEN
              REPEAT
                IF ExcelBuf.MARK THEN BEGIN
                  LastRow := ExcelBuf."Row No.";
                  IF FirstRow = 0 THEN
                    FirstRow := LastRow;
                END ELSE
                  IF FirstRow <> 0 THEN BEGIN
                    IF FirstRow = LastRow THEN
                      ThisCellHasFormulaError := AddToFormula(xlColID + FORMAT(FirstRow))
                    ELSE
                      ThisCellHasFormulaError :=
                        AddToFormula('SUM(' + xlColID + FORMAT(FirstRow) + ':' + xlColID + FORMAT(LastRow) + ')');
                    FirstRow := 0;
                    IF ThisCellHasFormulaError THEN
                      SetFormula(ExcelBuf.GetExcelReference(7));
                  END;
              UNTIL ThisCellHasFormulaError OR (ExcelBuf.NEXT = 0);

            IF NOT ThisCellHasFormulaError AND (FirstRow <> 0) THEN BEGIN
              IF FirstRow = LastRow THEN
                ThisCellHasFormulaError := AddToFormula(xlColID + FORMAT(FirstRow))
              ELSE
                ThisCellHasFormulaError :=
                  AddToFormula('SUM(' + xlColID + FORMAT(FirstRow) + ':' + xlColID + FORMAT(LastRow) + ')');
              FirstRow := 0;
              IF ThisCellHasFormulaError THEN
                SetFormula(ExcelBuf.GetExcelReference(7));
            END;

            ExcelBuf.RESET;
            ExcelBuf.GET("Row No.","Column No.");
            ExcelBuf.SetFormula(GetFormula);
            ExcelBuf.MODIFY;
            HasFormulaError := HasFormulaError OR ThisCellHasFormulaError;
          UNTIL NEXT = 0;

      EXIT(HasFormulaError);
    END;

    PROCEDURE AddToFormula@12(Text@1001 : Text[30]) : Boolean;
    VAR
      Overflow@1002 : Boolean;
      LongFormula@1000 : Text[1000];
    BEGIN
      LongFormula := GetFormula;
      IF LongFormula = '' THEN
        LongFormula := '=';
      IF LongFormula <> '=' THEN
        IF STRLEN(LongFormula) + 1 > MAXSTRLEN(LongFormula) THEN
          Overflow := TRUE
        ELSE
          LongFormula := LongFormula + '+';
      IF STRLEN(LongFormula) + STRLEN(Text) > MAXSTRLEN(LongFormula) THEN
        Overflow := TRUE
      ELSE
        SetFormula(LongFormula + Text);
      EXIT(Overflow);
    END;

    PROCEDURE GetFormula@13() : Text[1000];
    BEGIN
      EXIT(Formula + Formula2 + Formula3 + Formula4);
    END;

    PROCEDURE SetFormula@22(LongFormula@1000 : Text[1000]);
    BEGIN
      ClearFormula;
      IF LongFormula = '' THEN
        EXIT;

      Formula := COPYSTR(LongFormula,1,MAXSTRLEN(Formula));
      IF STRLEN(LongFormula) > MAXSTRLEN(Formula) THEN
        Formula2 := COPYSTR(LongFormula,MAXSTRLEN(Formula) + 1,MAXSTRLEN(Formula2));
      IF STRLEN(LongFormula) > MAXSTRLEN(Formula) + MAXSTRLEN(Formula2) THEN
        Formula3 := COPYSTR(LongFormula,MAXSTRLEN(Formula) + MAXSTRLEN(Formula2) + 1,MAXSTRLEN(Formula3));
      IF STRLEN(LongFormula) > MAXSTRLEN(Formula) + MAXSTRLEN(Formula2) + MAXSTRLEN(Formula3) THEN
        Formula4 := COPYSTR(LongFormula,MAXSTRLEN(Formula) + MAXSTRLEN(Formula2) + MAXSTRLEN(Formula3) + 1,MAXSTRLEN(Formula4));
    END;

    PROCEDURE ClearFormula@18();
    BEGIN
      Formula := '';
      Formula2 := '';
      Formula3 := '';
      Formula4 := '';
    END;

    PROCEDURE NewRow@14();
    BEGIN
      CurrentRow := CurrentRow + 1;
      CurrentCol := 0;
    END;

    PROCEDURE SetDefaultProperties@1000000034(DefaultValues@1000000000 : Variant);
    BEGIN
      CLEAR(TempDefaultsExcelBuf);
      IF DefaultValues.ISRECORD THEN
        TempDefaultsExcelBuf := DefaultValues;
      IF DefaultValues.ISTEXT THEN
        TempDefaultsExcelBuf.SetProperties(DefaultValues);

      TempDefaultsExcelBuf."Row No." := 0;
      TempDefaultsExcelBuf."Column No."  := 0;
      TempDefaultsExcelBuf.xlRowID := '';
      TempDefaultsExcelBuf.xlColID := '';
      TempDefaultsExcelBuf."Cell Value as Text" := '';
      TempDefaultsExcelBuf.SetFormula('');
    END;

    PROCEDURE AddColumn@16(Value@1000 : Variant;IsFormula@1001 : Boolean;CommentText@1002 : Text[1000];IsBold@1003 : Boolean;IsItalics@1004 : Boolean;IsUnderline@1005 : Boolean;NumFormat@1006 : Text[30];CellType@1007 : Option);
    BEGIN
      IF CurrentRow < 1 THEN
        NewRow;

      CurrentCol := CurrentCol + 1;
      INIT;
      TRANSFERFIELDS(TempDefaultsExcelBuf,FALSE);
      VALIDATE("Row No.",CurrentRow);
      VALIDATE("Column No.",CurrentCol);
      IF IsFormula THEN
        SetFormula(FORMAT(Value))
      ELSE
        "Cell Value as Text" := FORMAT(Value);
      Comment := CommentText;
      Bold := IsBold;
      Italic := IsItalics;
      Underline := IsUnderline;
      NumberFormat := NumFormat;
      "Cell Type" := CellType;
      INSERT;
    END;

    PROCEDURE AddColumnPr@1000000028(Value@1000 : Variant;IsFormula@1001 : Boolean;CellType@1007 : Option;Properties@1000000000 : Text);
    BEGIN
      IF CurrentRow < 1 THEN
        NewRow;

      CurrentCol := CurrentCol + 1;
      INIT;
      TRANSFERFIELDS(TempDefaultsExcelBuf,FALSE);
      VALIDATE("Row No.",CurrentRow);
      VALIDATE("Column No.",CurrentCol);
      IF IsFormula THEN
        SetFormula(FORMAT(Value))
      ELSE
        "Cell Value as Text" := FORMAT(Value);
      "Cell Type" := CellType;
      SetProperties(Properties);
      INSERT;
    END;

    PROCEDURE AddColumnHREF@1000000046(Value@1000 : Variant;Link@1001 : Text;CellType@1007 : Option;Properties@1000000000 : Text);
    BEGIN
      IF CurrentRow < 1 THEN
        NewRow;

      CurrentCol := CurrentCol + 1;
      INIT;
      TRANSFERFIELDS(TempDefaultsExcelBuf,FALSE);
      VALIDATE("Row No.",CurrentRow);
      VALIDATE("Column No.",CurrentCol);
      SetFormula(STRSUBSTNO('=HYPERLINK("%1","%2")',Link, Value));
      "Cell Type" := CellType;
      Underline := TRUE;
      "Font Color" := 'FF0000FF';
      SetProperties(Properties);
      INSERT;
    END;

    PROCEDURE AddAutoFilter@1000000025(RangeText@1000000000 : Text);
    BEGIN
      AutoFilterRange := RangeText;
    END;

    PROCEDURE AddFreezePane@1000000027(RowNo@1000000000 : Integer;ColNo@1000000001 : Integer);
    BEGIN
      FreezePaneRowNo := RowNo;
      FreezePaneColNo := ColNo;
    END;

    PROCEDURE StartRange@19();
    VAR
      DummyExcelBuf@1000 : Record 370;
    BEGIN
      DummyExcelBuf.VALIDATE("Row No.",CurrentRow);
      DummyExcelBuf.VALIDATE("Column No.",CurrentCol);

      RangeStartXlRow := DummyExcelBuf.xlRowID;
      RangeStartXlCol := DummyExcelBuf.xlColID;
    END;

    PROCEDURE EndRange@23();
    VAR
      DummyExcelBuf@1000 : Record 370;
    BEGIN
      DummyExcelBuf.VALIDATE("Row No.",CurrentRow);
      DummyExcelBuf.VALIDATE("Column No.",CurrentCol);

      RangeEndXlRow := DummyExcelBuf.xlRowID;
      RangeEndXlCol := DummyExcelBuf.xlColID;
    END;

    PROCEDURE CreateRange@45(RangeName@1000 : Text[250]);
    BEGIN
      AddDefinedName(
        RangeName,
        1,
        GetExcelReference(4) + RangeStartXlCol + GetExcelReference(4) + RangeStartXlRow +
        ':' +
        GetExcelReference(4) + RangeEndXlCol + GetExcelReference(4) + RangeEndXlRow);
    END;

    PROCEDURE CreateCellName@1000000040(RangeName@1000 : Text[250]);
    BEGIN
      AddDefinedName(
        RangeName,
        1,
        GetExcelReference(4) + xlColID + GetExcelReference(4) + xlRowID);
    END;

    PROCEDURE AutoFit@20(RangeName@1000 : Text[50]);
    BEGIN
      IF NOT ISNULL(XlWrkBk) THEN
        XlHelper.AutoFitRangeColumns(XlWrkBk,ActiveSheetName,RangeName);
    END;

    PROCEDURE BorderAround@39(RangeName@1000 : Text[50]);
    BEGIN
      IF NOT ISNULL(XlWrkBk) THEN
        XlHelper.BorderAroundRange(XlWrkBk,ActiveSheetName,RangeName,1);
    END;

    PROCEDURE ClearNewRow@26();
    BEGIN
      CurrentRow := 0;
      CurrentCol := 0;
    END;

    PROCEDURE SetUseInfoSheet@25();
    BEGIN
      UseInfoSheet := TRUE;
    END;

    PROCEDURE AddInfoColumn@24(Value@1006 : Variant;IsFormula@1005 : Boolean;IsBold@1003 : Boolean;IsItalics@1002 : Boolean;IsUnderline@1001 : Boolean;NumFormat@1000 : Text[30];CellType@1007 : Option);
    BEGIN
      IF CurrentRow < 1 THEN
        NewRow;

      CurrentCol := CurrentCol + 1;
      INIT;
      TempInfoExcelBuf.VALIDATE("Row No.",CurrentRow);
      TempInfoExcelBuf.VALIDATE("Column No.",CurrentCol);
      IF IsFormula THEN
        TempInfoExcelBuf.SetFormula(FORMAT(Value))
      ELSE
        TempInfoExcelBuf."Cell Value as Text" := FORMAT(Value);
      TempInfoExcelBuf.Bold := IsBold;
      TempInfoExcelBuf.Italic := IsItalics;
      TempInfoExcelBuf.Underline := IsUnderline;
      TempInfoExcelBuf.NumberFormat := NumFormat;
      TempInfoExcelBuf."Cell Type" := CellType;
      TempInfoExcelBuf.INSERT;
    END;

    PROCEDURE UTgetGlobalValue@35(globalVariable@1001 : Text[30];VAR value@1000 : Variant);
    BEGIN
      CASE globalVariable OF
        'CurrentRow':
          value := CurrentRow;
        'CurrentCol':
          value := CurrentCol;
        'RangeStartXlRow':
          value := RangeStartXlRow;
        'RangeStartXlCol':
          value := RangeStartXlCol;
        'RangeEndXlRow':
          value := RangeEndXlRow;
        'RangeEndXlCol':
          value := RangeEndXlCol;
        'XlWrkSht':
          value := XlWrkShtWriter;
        'ExcelFile':
          value := FileNameServer;
        ELSE
          ERROR(Text038,globalVariable);
      END;
    END;

    PROCEDURE SetCurrent@27(NewCurrentRow@1000 : Integer;NewCurrentCol@1001 : Integer);
    BEGIN
      CurrentRow := NewCurrentRow;
      CurrentCol := NewCurrentCol;
    END;

    PROCEDURE CreateValidationRule@17(Range@1000 : Code[20]);
    BEGIN
      XlWrkShtWriter.AddRangeDataValidation(
        Range,
        GetExcelReference(4) + RangeStartXlCol + GetExcelReference(4) + RangeStartXlRow +
        ':' +
        GetExcelReference(4) + RangeEndXlCol + GetExcelReference(4) + RangeEndXlRow);
    END;

    PROCEDURE QuitExcel@29();
    BEGIN
      // Close and clear the OpenXml book
      CloseBook;

      // Clear the worksheet automation
      IF NOT ISNULL(XlWrkSht) THEN
        CLEAR(XlWrkSht);

      // Clear the workbook automation
      IF NOT ISNULL(XlWrkBk) THEN
        CLEAR(XlWrkBk);

      // Clear and quit the Excel application automation
      IF NOT ISNULL(XlApp) THEN BEGIN
        XlHelper.CallQuit(XlApp);
        CLEAR(XlApp);
      END;
    END;

    PROCEDURE OpenExcel@31();
    VAR
      FileNameClient@1000 : Text;
    BEGIN
      IF OpenUsingDocumentService('') THEN
        EXIT;

      IF NOT PreOpenExcel THEN
        EXIT;

      // rename the Temporary filename into a more UI friendly name in a new subdirectory
      IF ClientPath = '' THEN BEGIN
        FileNameClient := FileManagement.DownloadTempFile(FileNameServer);
        FileNameClient := FileManagement.MoveAndRenameClientFile(FileNameClient,GetFriendlyFilename,FORMAT(CREATEGUID));
      END ELSE BEGIN
        FileNameClient := FileManagement.CombinePath(ClientPath,GetFriendlyFilename);
        FileManagement.DownloadToFile(FileNameServer,FileNameClient);
      END;

      XlWrkBk := XlHelper.CallOpen(XlApp,FileNameClient);

      PostOpenExcel;
    END;

    PROCEDURE DownloadAndOpenExcel@34();
    VAR
      ClientFilename@1000 : Text;
    BEGIN
      ClientFilename := GetFriendlyFilename;

      IF FileManagement.CanRunDotNetOnClient THEN BEGIN
        ClientFilename := FileManagement.SaveFileDialog('Save file','',Text034);
        IF ClientFilename = '' THEN
          EXIT;
        IF FileManagement.GetExtension(ClientFilename) = '' THEN
          ClientFilename += ExcelFileExtensionTok;
      END;

      OverwriteAndOpenExistingExcel(ClientFilename);
    END;

    PROCEDURE OverwriteAndOpenExistingExcel@15(FileName@1000 : Text);
    BEGIN
      IF FileName = '' THEN
        ERROR(Text001);

      IF OpenUsingDocumentService(FileName) THEN
        EXIT;

      IF NOT PreOpenExcel THEN
        EXIT;

      FileManagement.DownloadToFile(FileNameServer,FileName);
      XlWrkBk := XlHelper.CallOpen(XlApp,FileName);

      PostOpenExcel;
    END;

    PROCEDURE OpenExcelWithName@99(FileName@1000 : Text);
    BEGIN
      IF FileName = '' THEN
        ERROR(Text001);

      IF OpenUsingDocumentService(FileName) THEN
        EXIT;

      FileManagement.DownloadHandler(FileNameServer,'','',Text034,FileName);
    END;

    LOCAL PROCEDURE OpenUsingDocumentService@21(FileName@1000 : Text) : Boolean;
    VAR
      DocumentServiceMgt@1005 : Codeunit 9510;
      FileMgt@1004 : Codeunit 419;
      PathHelper@1003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Path";
      DialogWindow@1002 : Dialog;
      DocumentUrl@1001 : Text;
    BEGIN
      IF NOT EXISTS(FileNameServer) THEN
        ERROR(Text003,FileNameServer);

      // if document service is configured we save the generated document to SharePoint and open it from there.
      IF DocumentServiceMgt.IsConfigured THEN BEGIN
        IF FileName = '' THEN
          FileName := 'Book.' + PathHelper.ChangeExtension(PathHelper.GetRandomFileName,'xlsx')
        ELSE BEGIN
          // if file is not applicable for the service it can not be opened using the document service.
          IF NOT DocumentServiceMgt.IsServiceUri(FileName) THEN
            EXIT(FALSE);

          FileName := FileMgt.GetFileName(FileName);
        END;

        DialogWindow.OPEN(STRSUBSTNO(SavingDocumentMsg,FileName));
        DocumentUrl := DocumentServiceMgt.SaveFile(FileNameServer,FileName,TRUE);
        DocumentServiceMgt.OpenDocument(DocumentUrl);
        DialogWindow.CLOSE;
        EXIT(TRUE);
      END;

      EXIT(FALSE);
    END;

    LOCAL PROCEDURE PreOpenExcel@7() : Boolean;
    BEGIN
      IF NOT EXISTS(FileNameServer) THEN
        ERROR(Text003,FileNameServer);

      // Download file, if none RTC it should return a filename, and use client automation instead.
      IF NOT FileManagement.CanRunDotNetOnClient THEN BEGIN
        IF NOT FileManagement.DownloadHandler(FileNameServer,Text040,'',Text034,GetFriendlyFilename) THEN
          ERROR(Text001);
        EXIT(FALSE);
      END;

      XlApp := XlApp.ApplicationClass;
      IF ISNULL(XlApp) THEN
        ERROR(Text000);

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE PostOpenExcel@8();
    BEGIN
      XlWrkBk := XlApp.ActiveWorkbook;

      IF ISNULL(XlWrkBk) THEN
        ERROR(Text036);

      // autofit all columns on all worksheets
      IF (NOT UseCustomColumns) AND (NOT SkipAutoFit) THEN
        XlHelper.AutoFitColumnsInAllWorksheets(XlWrkBk);

      // activate the previous saved sheet name in the workbook
      IF ActiveSheetID = 0 THEN
        XlHelper.ActivateSheet(XlWrkBk,ActiveSheetName);
    END;

    PROCEDURE CreateBookAndOpenExcel@32(FileName@1004 : Text;SheetName@1000 : Text[250];ReportHeader@1003 : Text;CompanyName2@1002 : Text;UserID2@1001 : Text);
    BEGIN
      CreateBook(FileName,SheetName);
      WriteSheet(ReportHeader,CompanyName2,UserID2);
      CloseBook;
      OpenExcel;
      GiveUserControl;
    END;

    LOCAL PROCEDURE UpdateProgressDialog@36(VAR ExcelBufferDialogManagement@1000 : Codeunit 5370;VAR LastUpdate@1001 : DateTime;CurrentCount@1002 : Integer;TotalCount@1004 : Integer) : Boolean;
    VAR
      CurrentTime@1003 : DateTime;
    BEGIN
      // Refresh at 100%, and every second in between 0% to 100%
      // Duration is measured in miliseconds -> 1 sec = 1000 ms
      CurrentTime := CURRENTDATETIME;
      IF (CurrentCount = TotalCount) OR (CurrentTime - LastUpdate >= 1000) THEN BEGIN
        LastUpdate := CurrentTime;
        IF NOT ExcelBufferDialogManagement.SetProgress(ROUND(CurrentCount / TotalCount * 10000,1)) THEN
          EXIT(FALSE);
      END;

      EXIT(TRUE)
    END;

    LOCAL PROCEDURE GetFriendlyFilename@46() : Text;
    BEGIN
      IF FriendlyName = '' THEN
        EXIT('Book1' + ExcelFileExtensionTok);

      EXIT(FileManagement.StripNotsupportChrInFileName(FriendlyName) + ExcelFileExtensionTok);
    END;

    PROCEDURE SetFriendlyFilename@41(Name@1000 : Text);
    BEGIN
      FriendlyName := Name;
    END;

    PROCEDURE SetClientPath@1000000039(Path@1000 : Text);
    BEGIN
      IF Path <> '' THEN
        IF NOT FileManagement.ClientDirectoryExists(Path) THEN
          ERROR(PathDoesNotExistErr, Path);

      ClientPath := Path;
    END;

    PROCEDURE ConvertDateTimeDecimalToDateTime@43(DateTimeAsOADate@1000 : Decimal) : DateTime;
    VAR
      DotNetDateTime@1003 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.DateTime";
      DotNetDateTimeWithKind@1002 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.DateTime";
      DotNetDateTimeKind@1001 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.DateTimeKind";
    BEGIN
      DotNetDateTime := DotNetDateTime.FromOADate(DateTimeAsOADate);
      DotNetDateTimeWithKind := DotNetDateTime.DateTime(DotNetDateTime.Ticks,DotNetDateTimeKind.Local);
      EXIT(DotNetDateTimeWithKind);
    END;

    PROCEDURE SetSkipAutoFit@51();
    BEGIN
      SkipAutoFit := TRUE;
    END;

    PROCEDURE AddNewSheet@1119429000(SheetName@1119429000 : Text[250]);
    BEGIN
      IF SheetName = '' THEN
        ERROR(Text002);

      XlWrkShtWriter := XlWrkBkWriter.AddWorksheet(SheetName);

      IF SheetName <> '' THEN BEGIN
        XlWrkShtWriter.Name := SheetName;
        ActiveSheetName := SheetName;
      END;
    END;

    PROCEDURE CopySheet@1000000003(NewSheetName@1000000000 : Text);
    BEGIN
      CLEAR(XmlWrkShtDoc);
      XmlWrkShtDoc := XmlWrkShtDoc.XmlDocument;
      XmlWrkShtDoc.LoadXml(XlWrkShtWriter.Worksheet.OuterXml);

      AddNewSheet(NewSheetName);
      XlWrkShtWriter.Worksheet.InnerXml(XmlWrkShtDoc.DocumentElement.InnerXml);
    END;

    PROCEDURE MergeCells@1119429007(RangeText@1119429000 : Text);
    BEGIN
      IF ISNULL(MergedCellsList) THEN
        MergedCellsList := MergedCellsList.List;

      MergedCellsList.Add(RangeText);
    END;

    LOCAL PROCEDURE GetColumnRecord@1000000009(ColumnNo@1000000000 : Integer);
    BEGIN
      IF NOT TempColumnsExcelBuf.GET(0, ColumnNo) THEN BEGIN
        TempColumnsExcelBuf.INIT;
        TempColumnsExcelBuf."Row No." := 0;
        TempColumnsExcelBuf.VALIDATE("Column No.", ColumnNo);
        TempColumnsExcelBuf.INSERT;
      END;
    END;

    PROCEDURE SetColumnsProperty@1000000007(ColumnNo@1000000005 : Variant;PropertyType@1000000004 : 'Width,,OutlineLevel,Hidden';Value@1000000002 : Variant);
    VAR
      FromRowNo@1000000006 : Integer;
      ToRowNo@1000000007 : Integer;
      FromColumnNo@1000000001 : Integer;
      ToColumnNo@1000000000 : Integer;
      I@1000000003 : Integer;
    BEGIN
      IF NOT GetIntegerRange(ColumnNo,FromRowNo,FromColumnNo,ToRowNo,ToColumnNo) THEN
        ERROR(InvalidValueErr, 'ColumnNo', ColumnNo);

      IF (FromColumnNo = 0) AND (ToColumnNo = 0) THEN BEGIN
        FromColumnNo := FromRowNo;
        ToColumnNo := ToRowNo;
      END;

      IF FromColumnNo < 1 THEN
        EXIT;

      FOR I := FromColumnNo TO ToColumnNo DO BEGIN
        GetColumnRecord(I);
        CASE PropertyType OF
          PropertyType::Width:
            TempColumnsExcelBuf.Width := Value;
          PropertyType::OutlineLevel:
            TempColumnsExcelBuf."Outline Level" := Value;
          PropertyType::Hidden:
            TempColumnsExcelBuf.Hidden := Value;
        END;
        TempColumnsExcelBuf.MODIFY;
      END;
    END;

    PROCEDURE SetColumnsSummaryToLeft@1000000008(Value@1000000000 : Boolean);
    BEGIN
      SummaryColumnsToLeft := Value;
    END;

    LOCAL PROCEDURE GetRowRecord@1000000013(RowNo@1000000000 : Integer);
    BEGIN
      IF NOT TempRowsExcelBuf.GET(RowNo,0) THEN BEGIN
        TempRowsExcelBuf.INIT;
        TempRowsExcelBuf."Row No." := RowNo;
        TempRowsExcelBuf."Column No." := 0;
        TempRowsExcelBuf.INSERT;
      END;
    END;

    PROCEDURE SetRowsProperty@1000000012(RowNo@1000000006 : Variant;PropertyType@1000000004 : ',Height,OutlineLevel,Hidden,Collapsed';Value@1000000002 : Variant);
    VAR
      FromRowNo@1000000001 : Integer;
      ToRowNo@1000000000 : Integer;
      FromColNo@1000000007 : Integer;
      ToColNo@1000000005 : Integer;
      I@1000000003 : Integer;
    BEGIN
      IF NOT GetIntegerRange(RowNo,FromRowNo,FromColNo,ToRowNo,ToColNo) THEN
        ERROR(InvalidValueErr, 'RowNo',RowNo);

      IF FromRowNo < 1 THEN
        EXIT;

      FOR I := FromRowNo TO ToRowNo DO BEGIN
        GetRowRecord(I);
        CASE PropertyType OF
          PropertyType::Height:
            TempRowsExcelBuf.Height := Value;
          PropertyType::OutlineLevel:
            TempRowsExcelBuf."Outline Level" := Value;
          PropertyType::Hidden:
            TempRowsExcelBuf.Hidden := Value;
          PropertyType::Collapsed:
            TempRowsExcelBuf.Collapsed := Value;
        END;
        TempRowsExcelBuf.MODIFY;
      END;
    END;

    PROCEDURE SetRowsSummaryAbove@1000000004(Value@1000000000 : Boolean);
    BEGIN
      SummaryRowsAbove := Value;
    END;

    [TryFunction]
    LOCAL PROCEDURE GetIntegerRange@1000000055(SourceValue@1000000000 : Variant;VAR FromRow@1000000001 : Integer;VAR FromCol@1000000006 : Integer;VAR ToRow@1000000002 : Integer;VAR ToCol@1000000007 : Integer);
    VAR
      FromText@1000000004 : Text;
      ToText@1000000005 : Text;
      ColumnCode@1000000008 : Code[3];
    BEGIN
      FromRow := 0;
      FromCol := 0;
      ToRow := 0;
      ToCol := 0;

      IF SourceValue.ISINTEGER THEN BEGIN
        FromRow := SourceValue;
        ToRow := SourceValue;
        EXIT;
      END;

      IF SourceValue.ISTEXT OR SourceValue.ISCODE THEN BEGIN
        SourceValue := DELCHR(SourceValue,'=','$');
        IF EVALUATE(FromRow, SourceValue) THEN BEGIN
          ToRow := FromRow;
          EXIT;
        END;

        IF (STRPOS(SourceValue,':') > 0) THEN BEGIN
          FromText := COPYSTR(SourceValue,1, STRPOS(SourceValue,':') - 1);
          SplitCellAddress(FromText, ColumnCode, FromRow);
          IF ColumnCode <> '' THEN
            FromCol := GetColumnInt(ColumnCode);
          SourceValue := COPYSTR(SourceValue,STRPOS(SourceValue,':') + 1);
        END;

        SplitCellAddress(SourceValue, ColumnCode, ToRow);
        IF ColumnCode <> '' THEN
          ToCol := GetColumnInt(ColumnCode);

        IF (FromRow = 0) AND (FromCol = 0) THEN BEGIN
          FromRow := ToRow;
          FromCol := ToCol;
        END;

        EXIT;
      END;

      ERROR(InvalidRangeErr, SourceValue);
    END;

    LOCAL PROCEDURE GetColumnInt@1000000054(ColumnCode@1000000000 : Text[3]) : Integer;
    VAR
      I@1000000001 : Integer;
      J@1000000003 : Integer;
      ReturnValue@1000000002 : Integer;
    BEGIN
      ColumnCode := UPPERCASE(ColumnCode);

      IF ColumnCode = '' THEN
        EXIT(0);

      J := 0;
      FOR I := STRLEN(ColumnCode) DOWNTO 1 DO BEGIN
        IF NOT (ColumnCode[I] IN ['A'..'Z']) THEN
          ERROR(InvalidColumnCodeErr, ColumnCode);
        IF J > 0 THEN
          ReturnValue += (ColumnCode[I] - 64) * POWER(26, J)
        ELSE
          ReturnValue := ReturnValue + (ColumnCode[I] - 64);
        J += 1;
      END;

      EXIT(ReturnValue);
    END;

    LOCAL PROCEDURE SplitCellAddress@1000000056(CellAddress@1000000000 : Text;VAR ColumnCode@1000000001 : Code[3];VAR RowId@1000000002 : Integer);
    VAR
      I@1000000003 : Integer;
    BEGIN
      ColumnCode := '';
      RowId := 0;

      IF CellAddress = '' THEN
        EXIT;

      CellAddress := UPPERCASE(DELCHR(CellAddress,'=','$'));

      FOR I := 1 TO STRLEN(CellAddress) DO BEGIN
        IF CellAddress[I] IN ['1'..'9'] THEN BEGIN
          IF NOT EVALUATE(RowId,COPYSTR(CellAddress,I)) THEN
            ERROR(InvalidCellAddrErr, CellAddress);
          IF I > 1 THEN
            ColumnCode := COPYSTR(CellAddress,1,I-1);
          EXIT;
        END;

        IF NOT (CellAddress[I] IN ['A'..'Z']) THEN
          ERROR(InvalidCellAddrErr, CellAddress);
      END;
      ColumnCode := CellAddress;
    END;

    PROCEDURE AddImage@1000000016(RowID@1000000000 : Integer;ColID@1000000001 : Integer;FileName@1000000002 : Text[1000];FileIsOnServer@1000000003 : Boolean);
    BEGIN
      TempImageExcelBuf.INIT;
      TempImageExcelBuf.VALIDATE("Row No.", RowID);
      TempImageExcelBuf.VALIDATE("Column No.", ColID);
      TempImageExcelBuf.SetFormula(FileName);
      TempImageExcelBuf.Bold := FileIsOnServer;
      TempImageExcelBuf.INSERT;
    END;

    PROCEDURE SetTabColor@1000000022(NewTabColor@1000000000 : Text[20]);
    BEGIN
      TabColorText := NewTabColor;
    END;

    PROCEDURE SetProperties@1000000024(Properties@1000000010 : Text);
    VAR
      Field@1000000006 : Record 2000000041;
      RecRef@1000000007 : RecordRef;
      FieldRef@1000000005 : FieldRef;
      Pos@1000000001 : Integer;
      Text@1000000002 : Text;
      FieldName@1000000003 : Text;
      FieldValue@1000000004 : Text;
    BEGIN
      IF Properties = '' THEN
        EXIT;

      RecRef.GETTABLE(Rec);

      WHILE Properties <> '' DO BEGIN
        Pos := STRPOS(Properties,';');
        Text := '';
        IF Pos > 0 THEN BEGIN
          IF Pos > 1 THEN
            Text := COPYSTR(Properties,1,Pos-1);
          Properties := COPYSTR(Properties, Pos + 1);
        END ELSE BEGIN
          Text := Properties;
          Properties := '';
        END;

        WHILE (Text <> '') AND (Text[1] = ' ') DO
          Text := COPYSTR(Text, 2);

        WHILE (Text <> '') AND (Text[STRLEN(Text)] = ' ') DO
          Text := COPYSTR(Text, 1, STRLEN(Text) - 1);

        FieldName := '';
        FieldValue := '';
        Pos := STRPOS(Text,':');
        IF Pos > 0 THEN BEGIN
          FieldName := COPYSTR(Text,1,Pos-1);
          FieldValue := COPYSTR(Text,Pos+1);
        END ELSE
          FieldName := Text;

        Field.RESET;
        Field.SETRANGE(TableNo, RecRef.NUMBER);
        Field.SETRANGE(FieldName, FieldName);
        IF Field.FINDFIRST THEN BEGIN
          FieldRef := RecRef.FIELD(Field."No.");

          IF (Field.Type = Field.Type::Boolean) AND (FieldValue = '') THEN
            FieldValue := 'True';
          EVALUATE(FieldRef,FieldValue);
        END;
      END;

      RecRef.SETTABLE(Rec);
    END;

    PROCEDURE SetPortraitOrientation@1000000029();
    BEGIN
      PortraitOrientation := TRUE;
    END;

    PROCEDURE SetFitToPage@1000000033(Value@1000000000 : 'NoScale,Sheet,Columns,Rows');
    BEGIN
      FitToPageMode := Value;
    END;

    PROCEDURE SetPageMargins@1000000032(Left@1000000000 : Decimal;Top@1000000001 : Decimal;Right@1000000002 : Decimal;Bottom@1000000003 : Decimal;Header@1000000004 : Decimal;Footer@1000000005 : Decimal);
    BEGIN
      CustomPageMargins := TRUE;
      LeftMargin := Left;
      RightMargin := Right;
      TopMargin := Top;
      BottomMargin := Bottom;
      HeaderMargin := Header;
      FooterMargin := Footer;
    END;

    PROCEDURE SetPageMarginsNarrow@1000000035();
    BEGIN
      SetPageMargins(0.25, 0.75, 0.25, 0.75, 0.3, 0.3);
    END;

    PROCEDURE SetPageMarginsWide@1000000037();
    BEGIN
      SetPageMargins(1, 1, 1, 1, 0.5, 0.5);
    END;

    PROCEDURE SetFirstSheetActive@1000000041();
    BEGIN
      ActiveSheetID := 1;
    END;

    PROCEDURE SetCurrSheetActive@1000000042();
    BEGIN
      ActiveSheetID := CurrSheetID + 1;
    END;

    PROCEDURE ProtectSheet@1000000061(HashValue@1000000001 : Text;SaltValue@1000000002 : Text;SpinCount@1000000003 : Integer);
    VAR
      Base64BinaryValue@1000000013 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Base64BinaryValue";
    BEGIN
      XlSheetProtection := XlSheetProtection.SheetProtection();
      XlSheetProtection.Sheet := OpenXmlBoolValue.FromBoolean(TRUE);
      XlSheetProtection.Objects := OpenXmlBoolValue.FromBoolean(TRUE);
      XlSheetProtection.Scenarios := OpenXmlBoolValue.FromBoolean(TRUE);
      XlSheetProtection.Sheet := OpenXmlBoolValue.FromBoolean(TRUE);
      XlSheetProtection.AutoFilter := OpenXmlBoolValue.FromBoolean(FALSE);

      IF HashValue <> '' THEN BEGIN
        XlSheetProtection.AlgorithmName := OpenXmlStringValue.FromString('SHA-512');
        XlSheetProtection.HashValue := Base64BinaryValue.FromString(HashValue);
        XlSheetProtection.SaltValue := Base64BinaryValue.FromString(SaltValue);
        XlSheetProtection.SpinCount := OpenXmlUInt32Value.FromUInt32(SpinCount);
      END;
    END;

    LOCAL PROCEDURE GetCellDecorator@33(ExcelBuffer@1119429013 : Record 50000;VAR Decorator@1119429001 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.CellDecorator");
    BEGIN
      Decorator := XlWrkShtWriter.DefaultCellDecorator;

      GetFontDecorator(ExcelBuffer, Decorator);
      GetFillDecorator(ExcelBuffer, Decorator);
      GetBorderDecorator(ExcelBuffer, Decorator);
    END;

    LOCAL PROCEDURE GetFontDecorator@1119429002(ExcelBuffer@1119429013 : Record 50000;VAR Decorator@1119429001 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.CellDecorator");
    VAR
      FontXMLString@1119429005 : Text;
    BEGIN
      WITH ExcelBuffer DO BEGIN

        IF ("Font Name" = '') AND
           ("Font Size" = 0) AND
           ("Font Color" = '') AND
           (NOT (Bold OR Italic OR Underline OR "Double Underline"))
        THEN
           EXIT;

        FontXMLString := '';

        IF Bold THEN
          FontXMLString += '<x:b val="1" />';

        IF Italic THEN
          FontXMLString += '<x:i val="1" />';

        IF "Double Underline" THEN
          FontXMLString += '<x:u val="double" />'
        ELSE IF Underline THEN
          FontXMLString += '<x:u val="single" />';

        IF "Font Size" <> 0 THEN
          FontXMLString += STRSUBSTNO('<x:sz val="%1" />',"Font Size");

        IF "Font Color" <> '' THEN
          FontXMLString += STRSUBSTNO('<x:color rgb="%1" />',GetHEXColorCode("Font Color"));

        IF "Font Name" <> '' THEN
          FontXMLString += STRSUBSTNO('<x:name val="%1" />',"Font Name");

        Decorator.Font.InnerXml(FontXMLString);

      END;
    END;

    LOCAL PROCEDURE GetFillDecorator@1119429003(ExcelBuffer@1119429013 : Record 50000;VAR Decorator@1119429001 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.CellDecorator");
    BEGIN
      WITH ExcelBuffer DO BEGIN
        IF ("Background Color" = '') THEN
          EXIT;

        Decorator.Fill.InnerXml(
          '<x:patternFill xmlns:x="http://schemas.openxmlformats.org/spreadsheetml/2006/main" patternType="solid">' +
            '<x:fgColor rgb="' + GetHEXColorCode("Background Color") + '" />' +
          '</x:patternFill>');
      END;
    END;

    LOCAL PROCEDURE GetBorderDecorator@1119429004(ExcelBuffer@1119429013 : Record 50000;VAR Decorator@1119429001 : DotNet "'Microsoft.Dynamics.Nav.OpenXml, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.Microsoft.Dynamics.Nav.OpenXml.Spreadsheet.CellDecorator");
    VAR
      BorderXMLString@1119429005 : Text;
    BEGIN
      WITH ExcelBuffer DO BEGIN
        IF "Border Style" <> "Border Style"::None THEN BEGIN

          IF "Left Border Style" = "Left Border Style"::None THEN
            "Left Border Style" := "Border Style";
          IF "Right Border Style" = "Right Border Style"::None THEN
            "Right Border Style" := "Border Style";
          IF "Top Border Style" = "Top Border Style"::None THEN
            "Top Border Style" := "Border Style";
          IF "Bottom Border Style" = "Bottom Border Style"::None THEN
            "Bottom Border Style" := "Border Style";

          IF "Border Color" <> '' THEN BEGIN
            IF "Left Border Color" = '' THEN
              "Left Border Color" := "Border Color";
            IF "Right Border Color" = '' THEN
              "Right Border Color" := "Border Color";
            IF "Top Border Color" = '' THEN
              "Top Border Color" := "Border Color";
            IF "Bottom Border Color" = '' THEN
              "Bottom Border Color" := "Border Color";
          END;
        END;

        IF ("Left Border Style" = "Left Border Style"::None) AND
           ("Right Border Style" = "Right Border Style"::None) AND
           ("Top Border Style" = "Top Border Style"::None) AND
           ("Bottom Border Style" = "Bottom Border Style"::None) AND
           ("Diagonal Border Style" = "Diagonal Border Style"::None)
        THEN
          EXIT;

        BorderXMLString := '';
        WriteBorderXML('left', "Left Border Style", "Left Border Color", BorderXMLString);
        WriteBorderXML('right', "Right Border Style", "Right Border Color", BorderXMLString);
        WriteBorderXML('top', "Top Border Style", "Top Border Color", BorderXMLString);
        WriteBorderXML('bottom', "Bottom Border Style", "Bottom Border Color", BorderXMLString);
        WriteBorderXML('diagonal', "Diagonal Border Style", "Diagonal Border Color", BorderXMLString);
        Decorator.Border.InnerXml(BorderXMLString);
      END;
    END;

    LOCAL PROCEDURE GetHEXColorCode@1119429001(ColorName@1119429000 : Text[10]) : Text[10];
    BEGIN
      CASE LOWERCASE(ColorName) OF
        'black': EXIT('00000000');
        'white': EXIT('FFFFFFFF');
        'dark red': EXIT('FFC00000');
        'red': EXIT('FFFF0000');
        'orange': EXIT('FFFFC000');
        'yellow': EXIT('FFFFFF00');
        'light green': EXIT('FF92D050');
        'green': EXIT('FF00B050');
        'light blue': EXIT('FF00B0F0');
        'blue': EXIT('FF0070C0');
        'dark blue': EXIT('FF002060');
        'purple': EXIT('FF7030A0');
        ELSE EXIT(ColorName);
      END;
    END;

    LOCAL PROCEDURE WriteBorderXML@1119429005(BorderName@1119429000 : Text[10];BorderStyle@1119429001 : 'None,thin,medium,dashed,dotted,thick,double,hair,mediumDashed,dashDot,mediumDashDot,dashDotDot,mediumDashDotDot,slantDashDot';BorderColor@1119429002 : Text;VAR XMLText@1119429003 : Text);
    BEGIN
      IF BorderStyle = BorderStyle::None THEN
        XMLText += STRSUBSTNO('<x:%1 />',BorderName)
      ELSE BEGIN
        XMLText += STRSUBSTNO('<x:%1 style="%2" >',BorderName, BorderStyle);
        IF BorderColor = '' THEN
          XMLText += '<x:color auto="1" />'
        ELSE
          XMLText += STRSUBSTNO('<x:color rgb="%1" />',GetHEXColorCode(BorderColor));
        XMLText += STRSUBSTNO('</x:%1>', BorderName);
      END;
    END;

    PROCEDURE SetHideDialog@1119429006(SetValue@1119429000 : Boolean);
    BEGIN
      HideDialog := SetValue;
    END;

    LOCAL PROCEDURE WriteAutoFilter@1000000026();
    VAR
      XlAutoFilter@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.AutoFilter";
    BEGIN
      IF AutoFilterRange = '' THEN
        EXIT;

      XlAutoFilter := XlAutoFilter.AutoFilter;
      XlAutoFilter.Reference := OpenXmlStringValue.StringValue(AutoFilterRange);
      AppendOpenXmlElement(XlWrkShtWriter.Worksheet, XlAutoFilter);

      AutoFilterRange := '';
    END;

    LOCAL PROCEDURE WriteMergedCells@1119429009();
    VAR
      XlMergeCells@1119429003 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.MergeCells";
      XlMergeCell@1119429002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.MergeCell";
      I@1119429000 : Integer;
    BEGIN
      IF ISNULL(MergedCellsList) THEN
        EXIT;
      IF MergedCellsList.Count = 0 THEN
        EXIT;

      XlMergeCells := XlMergeCells.MergeCells();
      FOR I := 1 TO MergedCellsList.Count DO BEGIN
        XlMergeCell := XlMergeCell.MergeCell();
        XlMergeCell.Reference := OpenXmlStringValue.FromString(MergedCellsList.Item(I-1));
        AppendOpenXmlElement(XlMergeCells, XlMergeCell);
      END;
      AppendOpenXmlElement(XlWrkShtWriter.Worksheet, XlMergeCells);

      MergedCellsList.Clear;
    END;

    LOCAL PROCEDURE AddEmptyRows@1000000038();
    BEGIN
      TempRowsExcelBuf.RESET;
      IF TempRowsExcelBuf.FINDSET THEN
        REPEAT
          SETRANGE("Row No.", TempRowsExcelBuf."Row No.");
          IF ISEMPTY THEN BEGIN
            INIT;
            VALIDATE("Row No.",TempRowsExcelBuf."Row No.");
            VALIDATE("Column No.",1);
            //"Cell Type" := CellType;
            INSERT;
          END;
        UNTIL TempRowsExcelBuf.NEXT = 0;
      SETRANGE("Row No.");
    END;

    LOCAL PROCEDURE WriteColumnsProperties@1000000006();
    VAR
      TempColumnsExcelBuf2@1000000014 : TEMPORARY Record 50000;
      OpenXmlElement@1000000010 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlElement";
      OpenXmlColumns@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Columns";
      OpenXmlColumn@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Column";
      OpenXmlByteValue@1000000009 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.ByteValue";
      OpenXmlDoubleValue@1000000015 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.DoubleValue";
      MinColNo@1000000004 : Integer;
      MaxColNo@1000000005 : Integer;
      Pos@1000000006 : Integer;
      DoNext@1000000007 : Boolean;
    BEGIN
      TempColumnsExcelBuf.RESET;
      IF TempColumnsExcelBuf.FINDSET THEN BEGIN

        FOREACH OpenXmlElement IN XlWrkShtWriter.Worksheet.ChildElements DO
            IF OpenXmlElement.GetType.Equals(GETDOTNETTYPE(OpenXmlColumns)) THEN
              OpenXmlColumns := OpenXmlElement;

        IF ISNULL(OpenXmlColumns) THEN BEGIN
          XlWrkShtWriter.SetColumnWidth('A',20);
          FOREACH OpenXmlElement IN XlWrkShtWriter.Worksheet.ChildElements DO
            IF OpenXmlElement.GetType.Equals(GETDOTNETTYPE(OpenXmlColumns)) THEN BEGIN
              OpenXmlColumns := OpenXmlElement;
              OpenXmlColumn := OpenXmlColumns.LastChild;
              OpenXmlColumn.Remove;
            END;
        END;
        IF ISNULL(OpenXmlColumns) THEN
          EXIT;

        REPEAT
          TempColumnsExcelBuf2 := TempColumnsExcelBuf;
          MinColNo := TempColumnsExcelBuf2."Column No.";
          MaxColNo := MinColNo;
          DoNext := TempColumnsExcelBuf.NEXT <> 0;
          WHILE DoNext DO BEGIN
            IF (TempColumnsExcelBuf.Width = TempColumnsExcelBuf2.Width) AND
               (TempColumnsExcelBuf.Hidden = TempColumnsExcelBuf2.Hidden) AND
               (TempColumnsExcelBuf."Outline Level" = TempColumnsExcelBuf2."Outline Level") AND
               (TempColumnsExcelBuf."Column No." = TempColumnsExcelBuf2."Column No." + 1)
            THEN BEGIN
              TempColumnsExcelBuf2 := TempColumnsExcelBuf;
              MaxColNo := TempColumnsExcelBuf2."Column No.";
              DoNext := TempColumnsExcelBuf.NEXT <> 0;
            END ELSE
              DoNext := FALSE;
          END;
          TempColumnsExcelBuf := TempColumnsExcelBuf2;

          OpenXmlColumn := OpenXmlColumn.Column();
          OpenXmlColumn.Min := OpenXmlUInt32Value.FromUInt32(MinColNo);
          OpenXmlColumn.Max := OpenXmlUInt32Value.FromUInt32(MaxColNo);

          IF TempColumnsExcelBuf.Width > 0 THEN BEGIN
            OpenXmlColumn.CustomWidth := OpenXmlBoolValue.BooleanValue(TRUE);
            OpenXmlColumn.Width := OpenXmlDoubleValue.FromDouble(TempColumnsExcelBuf.Width / 7);
          END;

          IF TempColumnsExcelBuf.Hidden THEN
            OpenXmlColumn.Hidden := OpenXmlBoolValue.BooleanValue(TRUE);

          IF TempColumnsExcelBuf."Outline Level" > 0 THEN BEGIN
            OpenXmlColumn.OutlineLevel := OpenXmlByteValue.FromByte(TempColumnsExcelBuf."Outline Level");

            IF ISNULL(OpenXmlColumn.Width) THEN
              OpenXmlColumn.Width := OpenXmlDoubleValue.FromDouble(64/7);
          END;

          IF (TempColumnsExcelBuf.Width > 0) OR
             (TempColumnsExcelBuf.Hidden) OR
             (TempColumnsExcelBuf."Outline Level" > 0)
          THEN BEGIN
            AppendOpenXmlElement(OpenXmlColumns, OpenXmlColumn);
            UseCustomColumns := TRUE;
          END;

        UNTIL TempColumnsExcelBuf.NEXT = 0;
      END;

      TempColumnsExcelBuf.RESET;
      TempColumnsExcelBuf.DELETEALL;
    END;

    LOCAL PROCEDURE WriteRowsProperties@1000000017();
    VAR
      OpenXmlElement@1000000010 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlElement";
      OpenXmlSheetData@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.SheetData";
      OpenXmlRow@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Row";
      OpenXmlByteValue@1000000009 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.ByteValue";
      OpenXmlDoubleValue@1000000015 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.DoubleValue";
      I@1000000004 : Integer;
      FromRowNo@1000000005 : Integer;
    BEGIN
      TempRowsExcelBuf.RESET;
      IF TempRowsExcelBuf.FINDSET THEN BEGIN

        FOREACH OpenXmlElement IN XlWrkShtWriter.Worksheet.ChildElements DO
          IF OpenXmlElement.GetType.Equals(GETDOTNETTYPE(OpenXmlSheetData)) THEN
            OpenXmlSheetData := OpenXmlElement;

        IF ISNULL(OpenXmlSheetData) THEN
          EXIT;

        IF NOT OpenXmlSheetData.HasChildren THEN
          EXIT;

        REPEAT
          CLEAR(OpenXmlRow);
          FromRowNo := OpenXmlSheetData.ChildElements.Count-1;
          IF TempRowsExcelBuf."Row No." < FromRowNo THEN
            FromRowNo := TempRowsExcelBuf."Row No.";
          FOR I := FromRowNo DOWNTO 0 DO
            IF OpenXmlSheetData.ChildElements.Item(I).GetType.Equals(GETDOTNETTYPE(OpenXmlRow)) THEN BEGIN
              OpenXmlRow := OpenXmlSheetData.ChildElements.Item(I);
              OpenXmlUInt32Value := OpenXmlRow.RowIndex;
              IF OpenXmlUInt32Value.Value = TempRowsExcelBuf."Row No." THEN
                I := 0
              ELSE
                CLEAR(OpenXmlRow);
            END;

          IF NOT ISNULL(OpenXmlRow) THEN BEGIN

            IF TempRowsExcelBuf.Height > 0 THEN BEGIN
              OpenXmlRow.CustomHeight := OpenXmlBoolValue.BooleanValue(TRUE);
              OpenXmlRow.Height := OpenXmlDoubleValue.FromDouble(TempRowsExcelBuf.Height * 0.75);
            END;

            IF TempRowsExcelBuf.Hidden THEN
              OpenXmlRow.Hidden := OpenXmlBoolValue.BooleanValue(TRUE);

            IF TempRowsExcelBuf."Outline Level" > 0 THEN
              OpenXmlRow.OutlineLevel := OpenXmlByteValue.FromByte(TempRowsExcelBuf."Outline Level");

            IF TempRowsExcelBuf.Collapsed THEN
              OpenXmlRow.Collapsed := OpenXmlBoolValue.BooleanValue(TRUE);
          END;
        UNTIL TempRowsExcelBuf.NEXT = 0;
      END;

      TempRowsExcelBuf.RESET;
      TempRowsExcelBuf.DELETEALL;
    END;

    LOCAL PROCEDURE WriteSheetProperties@1000000014();
    VAR
      OpenXmlSheetProperties@1000000003 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.SheetProperties";
      OpenXmlOutlineProperties@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.OutlineProperties";
      OpenXmlPageSetupPr@1000000005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PageSetupProperties";
      OpenXmlTabColor@1000000004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.TabColor";
      OpenXmlHexBinValue@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.HexBinaryValue";
    BEGIN
      IF SummaryColumnsToLeft OR SummaryRowsAbove OR (TabColorText <> '') OR (FitToPageMode <> FitToPageMode::NoScale) THEN BEGIN

        IF ISNULL(XlWrkShtWriter.Worksheet.SheetProperties) THEN
          XlWrkShtWriter.Worksheet.SheetProperties := OpenXmlSheetProperties.SheetProperties;
        OpenXmlSheetProperties := XlWrkShtWriter.Worksheet.SheetProperties;

        IF TabColorText <> '' THEN BEGIN
          OpenXmlSheetProperties.TabColor := OpenXmlTabColor.TabColor();
          OpenXmlSheetProperties.TabColor.Rgb := OpenXmlHexBinValue.FromString(TabColorText);
        END;

        IF SummaryColumnsToLeft OR SummaryRowsAbove THEN BEGIN
          OpenXmlOutlineProperties := OpenXmlOutlineProperties.OutlineProperties;
          IF SummaryColumnsToLeft THEN
            OpenXmlOutlineProperties.SummaryRight := OpenXmlBoolValue.BooleanValue(FALSE);

          IF SummaryRowsAbove THEN
            OpenXmlOutlineProperties.SummaryBelow := OpenXmlBoolValue.BooleanValue(FALSE);

          AppendOpenXmlElement(OpenXmlSheetProperties, OpenXmlOutlineProperties);
        END;

        IF FitToPageMode <> FitToPageMode::NoScale THEN BEGIN
          IF ISNULL(OpenXmlSheetProperties.PageSetupProperties) THEN
            OpenXmlSheetProperties.PageSetupProperties := OpenXmlPageSetupPr.PageSetupProperties();
          OpenXmlSheetProperties.PageSetupProperties.FitToPage := OpenXmlBoolValue.BooleanValue(TRUE);
        END;
      END;
      TabColorText := '';
      SummaryColumnsToLeft := FALSE;
      SummaryRowsAbove := FALSE;
      IF FitToPageMode = FitToPageMode::Sheet THEN
        FitToPageMode := FitToPageMode::NoScale;
    END;

    LOCAL PROCEDURE WriteSheetViews@1000000030();
    VAR
      DummyExcelBuf@1000000008 : Record 370;
      OpenXmlWorksheet@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Worksheet";
      OpenXmlSheetViews@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.SheetViews";
      OpenXmlSheetView@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.SheetView";
      OpenXmlPane@1000000005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Pane";
      OpenXmlSelection@1000000012 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Selection";
      OpenXmlAttribute@1000000013 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlAttribute";
      OpenXmlDoubleValue@1000000011 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.DoubleValue";
      ColumnCode@1000000009 : Code[10];
    BEGIN
      IF (FreezePaneColNo < 2) AND (FreezePaneRowNo < 2) THEN
        EXIT;

      IF FreezePaneRowNo < 1 THEN
        FreezePaneRowNo := 1;
      IF FreezePaneColNo < 1 THEN
        FreezePaneColNo := 1;

      DummyExcelBuf.VALIDATE("Column No.", FreezePaneColNo);
      ColumnCode := DummyExcelBuf.xlColID;

      OpenXmlWorksheet := XlWrkShtWriter.Worksheet;

      IF ISNULL(OpenXmlWorksheet.SheetViews) THEN
        OpenXmlWorksheet.SheetViews := OpenXmlSheetViews.SheetViews();

      OpenXmlSheetView := OpenXmlSheetView.SheetView();
      //OpenXmlSheetView.TabSelected := OpenXmlBoolValue.BooleanValue(TRUE);
      OpenXmlSheetView.WorkbookViewId := OpenXmlUInt32Value.FromUInt32(0);

      OpenXmlPane := OpenXmlPane.Pane();
      OpenXmlPane.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('state', '', 'frozen'));    //OpenXmlPane.State := OpenXmlPaneStateValues.Frozen;
      OpenXmlPane.TopLeftCell := OpenXmlStringValue.FromString(STRSUBSTNO('%1%2',ColumnCode,FreezePaneRowNo));

      CASE TRUE OF
        (FreezePaneColNo > 2) AND (FreezePaneRowNo > 2):  // in the middle
          OpenXmlPane.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('activePane', '', 'bottomRight')); //OpenXmlPane.ActivePane := OpenXmlPaneValues.BottomRight;
        (FreezePaneRowNo > 2):  // Top rows
          OpenXmlPane.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('activePane', '', 'bottomLeft'));  //OpenXmlPane.ActivePane := OpenXmlPaneValues.BottomLeft;
        (FreezePaneColNo > 2):  // Top columns
          OpenXmlPane.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('activePane', '', 'topRight'));    //OpenXmlPane.ActivePane := OpenXmlPaneValues.TopRight;
      END;
      IF FreezePaneRowNo > 1 THEN
        OpenXmlPane.VerticalSplit := OpenXmlDoubleValue.FromDouble(FreezePaneRowNo-1);
      IF FreezePaneColNo > 1 THEN
        OpenXmlPane.HorizontalSplit := OpenXmlDoubleValue.FromDouble(FreezePaneColNo-1);
      AppendOpenXmlElement(OpenXmlSheetView, OpenXmlPane);

      IF FreezePaneColNo > 1 THEN BEGIN
        OpenXmlSelection := OpenXmlSelection.Selection();
        OpenXmlSelection.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('pane', '', 'topRight'));  //OpenXmlSelection.Pane := OpenXmlPaneValues.TopRight;
        AppendOpenXmlElement(OpenXmlSheetView, OpenXmlSelection);
      END;

      IF FreezePaneRowNo > 1 THEN BEGIN
        OpenXmlSelection := OpenXmlSelection.Selection();
        OpenXmlSelection.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('pane', '', 'bottomLeft'));  //OpenXmlSelection.Pane := OpenXmlPaneValues.BottomLeft;
        AppendOpenXmlElement(OpenXmlSheetView, OpenXmlSelection);
      END;

      IF (FreezePaneRowNo > 1) AND (FreezePaneColNo > 1) THEN BEGIN
        OpenXmlSelection := OpenXmlSelection.Selection();
        OpenXmlSelection.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('pane', '', 'bottomRight'));  //OpenXmlSelection.Pane := OpenXmlPaneValues.BottomRight;
        AppendOpenXmlElement(OpenXmlSheetView, OpenXmlSelection);
      END;

      AppendOpenXmlElement(OpenXmlWorksheet.SheetViews, OpenXmlSheetView);

      FreezePaneColNo := 0;
      FreezePaneRowNo := 0;
    END;

    LOCAL PROCEDURE WritePageSetup@1000000031();
    VAR
      OrientationValues@1000000005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.OrientationValues";
      OpenXmlWorksheet@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Worksheet";
      OpenXmlPageSetup@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PageSetup";
      OpenXmlPageMargins@1000000006 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PageMargins";
      OpenXmlElement@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlElement";
      OpenXmlDoubleValue@1000000007 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.DoubleValue";
      NeedAppend@1000000003 : Boolean;
    BEGIN
      IF CustomPageMargins THEN BEGIN
        OpenXmlWorksheet := XlWrkShtWriter.Worksheet;
        NeedAppend := FALSE;
        FOREACH OpenXmlElement IN OpenXmlWorksheet.ChildElements DO
          IF OpenXmlElement.GetType.Equals(GETDOTNETTYPE(OpenXmlPageMargins)) THEN
            OpenXmlPageMargins := OpenXmlElement;

        IF ISNULL(OpenXmlPageMargins) THEN BEGIN
          OpenXmlPageMargins := OpenXmlPageMargins.PageMargins();
          NeedAppend := TRUE;
        END;

        OpenXmlPageMargins.Left := OpenXmlDoubleValue.FromDouble(LeftMargin);
        OpenXmlPageMargins.Right := OpenXmlDoubleValue.FromDouble(RightMargin);
        OpenXmlPageMargins.Top := OpenXmlDoubleValue.FromDouble(TopMargin);
        OpenXmlPageMargins.Bottom := OpenXmlDoubleValue.FromDouble(BottomMargin);
        OpenXmlPageMargins.Header := OpenXmlDoubleValue.FromDouble(HeaderMargin);
        OpenXmlPageMargins.Footer := OpenXmlDoubleValue.FromDouble(FooterMargin);

        IF NeedAppend THEN
          AppendOpenXmlElement(OpenXmlWorksheet, OpenXmlPageMargins);
      END;
      CustomPageMargins := FALSE;

      IF PortraitOrientation THEN
        XlWrkShtWriter.AddPageSetup(OrientationValues.Portrait)
      ELSE
        XlWrkShtWriter.AddPageSetup(OrientationValues.Landscape,9);
      PortraitOrientation := FALSE;

      IF FitToPageMode IN [FitToPageMode::Columns,FitToPageMode::Rows] THEN BEGIN

        OpenXmlWorksheet := XlWrkShtWriter.Worksheet;
        FOREACH OpenXmlElement IN OpenXmlWorksheet.ChildElements DO
          IF OpenXmlElement.GetType.Equals(GETDOTNETTYPE(OpenXmlPageSetup)) THEN
            OpenXmlPageSetup := OpenXmlElement;

        IF NOT ISNULL(OpenXmlPageSetup) THEN BEGIN
          IF FitToPageMode = FitToPageMode::Columns THEN
            OpenXmlPageSetup.FitToHeight := OpenXmlUInt32Value.FromUInt32(0);

          IF FitToPageMode = FitToPageMode::Rows THEN
            OpenXmlPageSetup.FitToWidth := OpenXmlUInt32Value.FromUInt32(0);
        END;
      END;
      FitToPageMode := FitToPageMode::NoScale;


      IF PaperSize <> 0 THEN BEGIN

        OpenXmlWorksheet := XlWrkShtWriter.Worksheet;
        FOREACH OpenXmlElement IN OpenXmlWorksheet.ChildElements DO
          IF OpenXmlElement.GetType.Equals(GETDOTNETTYPE(OpenXmlPageSetup)) THEN
            OpenXmlPageSetup := OpenXmlElement;

        IF NOT ISNULL(OpenXmlPageSetup) THEN
            OpenXmlPageSetup.PaperSize(OpenXmlUInt32Value.FromUInt32(PaperSize));
      END;


    END;

    LOCAL PROCEDURE WriteSheetProtection@1000000065();
    VAR
      OpenXmlWorksheet@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Worksheet";
      OpenXmlElement@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlElement";
    BEGIN
      IF ISNULL(XlSheetProtection) THEN
        EXIT;

      OpenXmlWorksheet := XlWrkShtWriter.Worksheet;

      SkipAutoFit := TRUE;
      FOREACH OpenXmlElement IN OpenXmlWorksheet.ChildElements DO
        IF OpenXmlElement.GetType.Equals(GETDOTNETTYPE(XlSheetProtection)) THEN BEGIN
          OpenXmlElement := XlSheetProtection.CloneNode(TRUE);
          CLEAR(XlSheetProtection);
          EXIT;
        END;

      AppendOpenXmlElement(OpenXmlWorksheet, XlSheetProtection);
      CLEAR(XlSheetProtection);
    END;

    LOCAL PROCEDURE InitDrawingsPart@1000000010(VAR OpenXmlDrawingsPart@1000000009 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.DrawingsPart";VAR OpenXmlWorkSheetDrawing@1000000008 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.WorksheetDrawing");
    VAR
      OpenXmlWorksheet@1000000007 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Worksheet";
      OpenXmlWorkSheetPart@1000000006 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.WorksheetPart";
      OpenXmlDrawing@1000000011 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Drawing";
      OpenXmlElement@1000000010 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlElement";
      Type@1000000005 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Type";
      ArrOfTypes@1000000004 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      ArrNull@1000000003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      Method@1000000002 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Reflection.MethodInfo";
      GenericMethod@1000000001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Reflection.MethodInfo";
      Object@1000000000 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Object";
    BEGIN
      OpenXmlWorksheet := XlWrkShtWriter.Worksheet;
      OpenXmlWorkSheetPart := OpenXmlWorksheet.WorksheetPart;
      OpenXmlDrawingsPart := OpenXmlWorkSheetPart.DrawingsPart;

      IF ISNULL(OpenXmlDrawingsPart) THEN
        AddNewPart(OpenXmlWorkSheetPart,OpenXmlDrawingsPart);

      FOREACH OpenXmlElement IN OpenXmlWorksheet.ChildElements DO
        IF OpenXmlElement.GetType.Equals(GETDOTNETTYPE(OpenXmlDrawing)) THEN
          OpenXmlDrawing := OpenXmlElement;

      IF ISNULL(OpenXmlDrawing) THEN BEGIN
        OpenXmlDrawing := OpenXmlDrawing.Drawing;
        OpenXmlDrawing.Id := OpenXmlStringValue.StringValue;
        OpenXmlDrawing.Id.Value := OpenXmlWorkSheetPart.GetIdOfPart(OpenXmlDrawingsPart);
        AppendOpenXmlElement(OpenXmlWorksheet, OpenXmlDrawing);
      END;

      IF ISNULL(OpenXmlDrawingsPart.WorksheetDrawing) THEN
        OpenXmlDrawingsPart.WorksheetDrawing := OpenXmlWorkSheetDrawing.WorksheetDrawing();
      OpenXmlWorkSheetDrawing := OpenXmlDrawingsPart.WorksheetDrawing;
    END;

    LOCAL PROCEDURE InitImagePart@1000000018(VAR OpenXmlImagePart@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.ImagePart";VAR OpenXmlDrawingsPart@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.DrawingsPart";VAR Cx@1000000005 : BigInteger;VAR Cy@1000000004 : BigInteger);
    VAR
      OpenXmlImagePartType@1000000008 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.ImagePartType";
      Bitmap@1000000000 : DotNet "'System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.System.Drawing.Bitmap";
      FileStream@1000000007 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.FileStream";
      FileMode@1000000006 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.FileMode";
      ImageFileName@1000000009 : Text;
    BEGIN
      IF TempImageExcelBuf.GetFormula = '' THEN
        ERROR(Text001);

      IF TempImageExcelBuf.Bold THEN
        ImageFileName := TempImageExcelBuf.GetFormula
      ELSE
        IF FileManagement.ClientFileExists(TempImageExcelBuf.GetFormula) THEN
          ImageFileName := FileManagement.UploadFileSilent(TempImageExcelBuf.GetFormula)
        ELSE
          ERROR(Text003, TempImageExcelBuf.GetFormula);

      IF NOT EXISTS(ImageFileName) THEN
        ERROR(Text003, ImageFileName);

      OpenXmlImagePart := OpenXmlDrawingsPart.AddImagePart(OpenXmlImagePartType.Jpeg);
      FileStream := FileStream.FileStream(ImageFileName, FileMode.Open);
      OpenXmlImagePart.FeedData(FileStream);

      Bitmap := Bitmap.Bitmap(ImageFileName);
      Cx := ROUND(Bitmap.Width * (914400 / Bitmap.HorizontalResolution),1,'=');
      Cy := ROUND(Bitmap.Height * (914400 / Bitmap.VerticalResolution),1,'=');
      Bitmap.Dispose();
    END;

    LOCAL PROCEDURE WriteImages@1000000011();
    VAR
      FileManagement@1000000033 : Codeunit 419;
      OpenXmlDrawingsPart@1000000004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.DrawingsPart";
      OpenXmlWorkSheetDrawing@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.WorksheetDrawing";
      OpenXmlElement@1000000005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlElement";
      OpenXmlAttribute@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlAttribute";
      OpenXmlImagePart@1000000009 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.ImagePart";
      OpenXmlExtents@1000000016 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Extents";
      OpenXmlOneCellAnchor@1000000021 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.OneCellAnchor";
      OpenXmlExtent@1000000048 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.Extent";
      OpenXmlFromMarker@1000000022 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.FromMarker";
      OpenXmlPicture@1000000023 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.Picture";
      OpenXmlNonVisualDrawProp@1000000019 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.NonVisualDrawingProperties";
      OpenXmlNonVisualPictureProp@1000000024 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.NonVisualPictureProperties";
      OpenXmlNonVisualPictureDrawProp@1000000056 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.NonVisualPictureDrawingProperties";
      OpenXmlPictureLocks@1000000025 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.PictureLocks";
      OpenXmlBlipFill@1000000026 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.BlipFill";
      OpenXmlBlip@1000000027 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Blip";
      OpenXmlStretch@1000000028 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Stretch";
      OpenXmlFillRect@1000000052 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.FillRectangle";
      OpenXmlShapeProp@1000000029 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.ShapeProperties";
      OpenXmlTransform2D@1000000053 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Transform2D";
      OpenXmlOffset@1000000054 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Offset";
      OpenXmlPresetGeom@1000000030 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.PresetGeometry";
      OpenXmlClientData@1000000032 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Drawing.Spreadsheet.ClientData";
      Cx@1000000018 : BigInteger;
      Cy@1000000017 : BigInteger;
      NvpId@1000000034 : Integer;
    BEGIN
      TempImageExcelBuf.RESET;
      IF TempImageExcelBuf.FINDSET THEN BEGIN

        InitDrawingsPart(OpenXmlDrawingsPart, OpenXmlWorkSheetDrawing);

        NvpId := 0;
        FOREACH OpenXmlElement IN OpenXmlWorkSheetDrawing.ChildElements DO
          IF OpenXmlElement.GetType.Equals(GETDOTNETTYPE(OpenXmlNonVisualDrawProp)) THEN
            NvpId += 1;

        REPEAT

          InitImagePart(OpenXmlImagePart, OpenXmlDrawingsPart,Cx,Cy);
          NvpId += 1;

          OpenXmlOneCellAnchor := OpenXmlOneCellAnchor.OneCellAnchor;

            OpenXmlOneCellAnchor.FromMarker := OpenXmlFromMarker.FromMarker();
            OpenXmlOneCellAnchor.FromMarker.InnerXml :=
              STRSUBSTNO('<xdr:col>%1</xdr:col>' +
                         '<xdr:colOff>0</xdr:colOff>' +
                         '<xdr:row>%2</xdr:row>' +
                         '<xdr:rowOff>0</xdr:rowOff>',
                           TempImageExcelBuf."Column No." - 1,
                           TempImageExcelBuf."Row No." - 1);

            OpenXmlExtent := OpenXmlExtent.Extent;
            OpenXmlExtent.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('cx', '', FORMAT(Cx,0,9)));
            OpenXmlExtent.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('cy', '', FORMAT(Cy,0,9)));
            OpenXmlOneCellAnchor.Extent := OpenXmlExtent;

            OpenXmlPicture := OpenXmlPicture.Picture;

              OpenXmlPicture.NonVisualPictureProperties := OpenXmlNonVisualPictureProp.NonVisualPictureProperties;

                OpenXmlNonVisualDrawProp := OpenXmlNonVisualDrawProp.NonVisualDrawingProperties;
                OpenXmlNonVisualDrawProp.Id := OpenXmlUInt32Value.FromUInt32(NvpId);
                OpenXmlNonVisualDrawProp.Name := OpenXmlStringValue.StringValue(STRSUBSTNO('Picture %1', NvpId));
                OpenXmlNonVisualDrawProp.Description := OpenXmlStringValue.StringValue(FileManagement.GetFileName(TempImageExcelBuf.GetFormula));

                OpenXmlPicture.NonVisualPictureProperties.NonVisualDrawingProperties := OpenXmlNonVisualDrawProp;

                OpenXmlNonVisualPictureDrawProp := OpenXmlNonVisualPictureDrawProp.NonVisualPictureDrawingProperties;
                OpenXmlNonVisualPictureDrawProp.PictureLocks := OpenXmlPictureLocks.PictureLocks;
                OpenXmlNonVisualPictureDrawProp.PictureLocks.NoChangeAspect := OpenXmlBoolValue.BooleanValue(TRUE);

                OpenXmlPicture.NonVisualPictureProperties.NonVisualPictureDrawingProperties := OpenXmlNonVisualPictureDrawProp;

              OpenXmlBlipFill := OpenXmlBlipFill.BlipFill;

                OpenXmlBlipFill.Blip := OpenXmlBlip.Blip;
                OpenXmlBlipFill.Blip.Embed := OpenXmlStringValue.StringValue(OpenXmlDrawingsPart.GetIdOfPart(OpenXmlImagePart));
                OpenXmlBlipFill.Blip.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('cstate', '', 'print'));

                OpenXmlStretch := OpenXmlStretch.Stretch;
                OpenXmlStretch.FillRectangle := OpenXmlFillRect.FillRectangle;
                AppendOpenXmlElement(OpenXmlBlipFill,OpenXmlStretch);

              AppendOpenXmlElement(OpenXmlPicture, OpenXmlBlipFill);

              OpenXmlShapeProp := OpenXmlShapeProp.ShapeProperties;
              OpenXmlShapeProp.Transform2D := OpenXmlTransform2D.Transform2D();
              OpenXmlShapeProp.Transform2D.Offset := OpenXmlOffset.Offset();
              OpenXmlShapeProp.Transform2D.Offset.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('x', '', '0'));
              OpenXmlShapeProp.Transform2D.Offset.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('y', '', '0'));

              OpenXmlShapeProp.Transform2D.Extents := OpenXmlExtents.Extents;
              OpenXmlShapeProp.Transform2D.Extents.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('cx', '', FORMAT(Cx,0,9)));
              OpenXmlShapeProp.Transform2D.Extents.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('cy', '', FORMAT(Cy,0,9)));

                OpenXmlPresetGeom := OpenXmlPresetGeom.PresetGeometry;
                OpenXmlPresetGeom.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('prst', '', 'rect')); //OpenXmlPresetGeom.Preset := ShapeTypeValue.Rectangle;
                AppendOpenXmlElement(OpenXmlShapeProp, OpenXmlPresetGeom);

              AppendOpenXmlElement(OpenXmlPicture, OpenXmlShapeProp);

            AppendOpenXmlElement(OpenXmlOneCellAnchor,OpenXmlPicture);

            OpenXmlClientData := OpenXmlClientData.ClientData;
            AppendOpenXmlElement(OpenXmlOneCellAnchor, OpenXmlClientData);

          AppendOpenXmlElement(OpenXmlWorkSheetDrawing,OpenXmlOneCellAnchor);
        UNTIL TempImageExcelBuf.NEXT = 0;
      END;
      TempImageExcelBuf.DELETEALL;
    END;

    PROCEDURE HasCustomStyle@1000000069() : Boolean;
    BEGIN
      IF NOT ("Horizontal Alignment" IN
                ["Horizontal Alignment"::Left,
                 "Horizontal Alignment"::Right,
                 "Horizontal Alignment"::Distributed])
      THEN
        Indent := 0;

      IF NOT ("Text Rotation" IN [0..180]) THEN
        "Text Rotation" := 0;

      IF "Wrap Text" THEN
        "Shrink To Fit" := FALSE;

      IF ("Horizontal Alignment" = "Horizontal Alignment"::Automatic) AND
         ("Vertical Alignment" = "Vertical Alignment"::Automatic) AND
         (Indent = 0) AND
         ("Reading Order" = "Reading Order"::Context) AND
         ("Relative Indent" = 0) AND
         ("Shrink To Fit" = FALSE) AND
         ("Text Rotation" = 0) AND
         ("Wrap Text" = FALSE) AND
         ("Justify Last Line" = FALSE) AND
         (Unlocked = FALSE) AND
         ("Formula Hidden" = FALSE)
      THEN
        EXIT(FALSE);

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE WriteAlignment@1000000071(ExcelBufferDialogMgt@1000000019 : Codeunit 5370;LastUpdate@1000000016 : DateTime;RecNo@1000000018 : Integer;TotalRecNo@1000000017 : Integer);
    VAR
      XmlRowNodeList@1000000008 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeList";
      XmlRowNode@1000000009 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";
      XmlCellNodeList@1000000011 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeList";
      XmlCellNode@1000000010 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode";
      XmlNamespaceManager@1000000006 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNamespaceManager";
      CellFormats@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CellFormats";
      SheetChanged@1000000000 : Boolean;
    BEGIN
      FirstCustomStyleID := 0;
      SheetChanged := FALSE;
      CLEAR(XmlCellFormatsDoc);

      XmlWrkShtDoc := XmlWrkShtDoc.XmlDocument;
      XmlWrkShtDoc.LoadXml(XlWrkShtWriter.Worksheet.OuterXml);
      XMLDOMManagement.AddNamespaces(XmlNamespaceManager,XmlWrkShtDoc);

      XmlRowNodeList := XmlWrkShtDoc.SelectNodes('/x:worksheet/x:sheetData/x:row',XmlNamespaceManager);

      FOREACH XmlRowNode IN XmlRowNodeList DO BEGIN
        XmlCellNodeList := XmlRowNode.SelectNodes('x:c',XmlNamespaceManager);
        FOREACH XmlCellNode IN XmlCellNodeList DO BEGIN
          IF ChangeCellStyle(XmlCellNode) THEN BEGIN
            SheetChanged := TRUE;
            RecNo += 1;
            IF NOT HideDialog THEN
              IF NOT UpdateProgressDialog(ExcelBufferDialogMgt,LastUpdate,RecNo,TotalRecNo) THEN BEGIN
                QuitExcel;
                ERROR(Text035)
              END;
          END;
        END;
      END;

      IF SheetChanged THEN BEGIN
        XlWrkShtWriter.Worksheet.InnerXml(XmlWrkShtDoc.DocumentElement.InnerXml);
        CellFormats := XlWrkBkWriter.Workbook.WorkbookPart.WorkbookStylesPart.Stylesheet.CellFormats;
        CellFormats.InnerXml(XmlCellFormatsDoc.DocumentElement.InnerXml);
        CellFormats.Count := OpenXmlUInt32Value.FromUInt32(XmlCellFormatsDoc.DocumentElement.ChildNodes.Count);
      END;
      CLEAR(XmlWrkShtDoc);
    END;

    LOCAL PROCEDURE ChangeCellStyle@1000000070(VAR XmlCellNode@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNode") : Boolean;
    VAR
      CurrStyleCode@1000000008 : Code[10];
      CurrAddress@1000000007 : Text;
      CurrStyleID@1000000006 : Integer;
      NewStyleID@1000000005 : Integer;
      FromRowNo@1000000004 : Integer;
      ToRowNo@1000000003 : Integer;
      FromColumnNo@1000000002 : Integer;
      ToColumnNo@1000000001 : Integer;
    BEGIN
      CurrAddress := XMLDOMManagement.GetAttributeValue(XmlCellNode,'r');
      CurrStyleCode := XMLDOMManagement.GetAttributeValue(XmlCellNode,'s');

      IF NOT GetIntegerRange(CurrAddress,FromRowNo,FromColumnNo,ToRowNo,ToColumnNo) THEN
        EXIT(FALSE);

      IF NOT GET(FromRowNo,FromColumnNo) THEN
        EXIT(FALSE);

      IF NOT HasCustomStyle THEN
        EXIT(FALSE);

      IF NOT EVALUATE(CurrStyleID,CurrStyleCode) THEN
        EXIT(FALSE);

      NewStyleID := GetNewStyle(Rec,CurrStyleID);
      IF NewStyleID = CurrStyleID THEN
        EXIT(FALSE);

      XMLDOMManagement.AddAttribute(XmlCellNode,'s',FORMAT(NewStyleID,0,9));
      EXIT(TRUE);
    END;

    LOCAL PROCEDURE GetNewStyle@1000000002(ExcelBuffer@1000000006 : Record 50000;FromStyleID@1000000007 : Integer) : Integer;
    VAR
      XmlNewCellFormat@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlElement";
      XmlAlignmentNode@1000000005 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlElement";
      XmlProtectionNode@1000000001 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlElement";
      XmlNamespaceManager@1000000004 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNamespaceManager";
      xPath@1000000009 : Text;
      AttrValue@1000000010 : Text;
      NewStyleID@1000000011 : Integer;
    BEGIN

      IF ISNULL(XmlCellFormatsDoc) THEN BEGIN
        XmlCellFormatsDoc := XmlCellFormatsDoc.XmlDocument;
        XmlCellFormatsDoc.LoadXml(XlWrkBkWriter.Workbook.WorkbookPart.WorkbookStylesPart.Stylesheet.CellFormats.OuterXml);
        XMLDOMManagement.AddNamespaces(XmlNamespaceManager, XmlCellFormatsDoc);
      END;

      XmlNewCellFormat := XmlCellFormatsDoc.DocumentElement.ChildNodes.Item(FromStyleID).CloneNode(TRUE);

      XMLDOMManagement.AddElementWithPrefix(XmlNewCellFormat,'alignment','','x','http://schemas.openxmlformats.org/spreadsheetml/2006/main', XmlAlignmentNode);
      IF ExcelBuffer."Horizontal Alignment" <> ExcelBuffer."Horizontal Alignment"::Automatic THEN
        XMLDOMManagement.AddAttribute(XmlAlignmentNode,'horizontal',LOWERCASE(FORMAT(ExcelBuffer."Horizontal Alignment")));
      IF ExcelBuffer."Vertical Alignment" <> ExcelBuffer."Vertical Alignment"::Automatic THEN
        XMLDOMManagement.AddAttribute(XmlAlignmentNode,'vertical',LOWERCASE(FORMAT(ExcelBuffer."Vertical Alignment")));
      IF ExcelBuffer.Indent > 0 THEN
        XMLDOMManagement.AddAttribute(XmlAlignmentNode,'indent',FORMAT(ExcelBuffer.Indent,0,9));

      IF ExcelBuffer."Reading Order" <> ExcelBuffer."Reading Order"::Context THEN
        XMLDOMManagement.AddAttribute(XmlAlignmentNode,'readingOrder',FORMAT(ExcelBuffer."Reading Order",0,9));

      IF ExcelBuffer."Relative Indent" > 0 THEN
        XMLDOMManagement.AddAttribute(XmlAlignmentNode,'relativeIndent',FORMAT(ExcelBuffer."Relative Indent",0,9));

      IF ExcelBuffer."Shrink To Fit" THEN
        XMLDOMManagement.AddAttribute(XmlAlignmentNode,'shrinkToFit',FORMAT(ExcelBuffer."Shrink To Fit",0,9));

      IF ExcelBuffer."Text Rotation" > 0 THEN
        XMLDOMManagement.AddAttribute(XmlAlignmentNode,'textRotation',FORMAT(ExcelBuffer."Text Rotation",0,9));

      IF ExcelBuffer."Wrap Text" THEN
        XMLDOMManagement.AddAttribute(XmlAlignmentNode,'wrapText',FORMAT(ExcelBuffer."Wrap Text",0,9));

      IF ExcelBuffer."Justify Last Line" THEN
        XMLDOMManagement.AddAttribute(XmlAlignmentNode,'justifyLastLine',FORMAT(ExcelBuffer."Justify Last Line",0,9));

      XMLDOMManagement.AddAttribute(XmlNewCellFormat,'applyAlignment','1');

      IF ExcelBuffer.Unlocked OR ExcelBuffer."Formula Hidden" THEN BEGIN
        XMLDOMManagement.AddElementWithPrefix(XmlNewCellFormat,'protection','','x','http://schemas.openxmlformats.org/spreadsheetml/2006/main', XmlProtectionNode);
        XMLDOMManagement.AddAttribute(XmlProtectionNode,'hidden',FORMAT(ExcelBuffer."Formula Hidden",0,9));
        XMLDOMManagement.AddAttribute(XmlProtectionNode,'locked',FORMAT(NOT ExcelBuffer.Unlocked,0,9));
      END;

      NewStyleID := FindExistingStyle(XmlCellFormatsDoc.DocumentElement, LOWERCASE(XmlNewCellFormat.OuterXml));
      IF NewStyleID > 0 THEN
        EXIT(NewStyleID);

      XmlCellFormatsDoc.DocumentElement.AppendChild(XmlNewCellFormat);
      NewStyleID := XmlCellFormatsDoc.DocumentElement.ChildNodes.Count - 1;

      EXIT(NewStyleID);
    END;

    LOCAL PROCEDURE FindExistingStyle@1000000005(XmlCellFormatsNode@1000000001 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlElement";NewText@1000000005 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String") : Integer;
    VAR
      XmlOldCellFormat@1000000003 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlElement";
      String@1000000002 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String";
      I@1000000004 : Integer;
    BEGIN
      FOR I := FirstCustomStyleID TO XmlCellFormatsNode.ChildNodes.Count-1 DO BEGIN
        XmlOldCellFormat := XmlCellFormatsNode.ChildNodes.Item(I);
        IF FirstCustomStyleID = 0 THEN
          IF XMLDOMManagement.GetAttributeValue(XmlOldCellFormat, 'applyAlignment') = '1' THEN
            FirstCustomStyleID := I;
        String := LOWERCASE(XmlOldCellFormat.OuterXml);
        IF String.Equals(NewText) THEN
          EXIT(I);
      END;

      EXIT(0);
    END;

    LOCAL PROCEDURE SetCellComment@1000000015(ColId@1000000001 : Integer;RowId@1000000000 : Integer;CommentValue@1001 : Text);
    VAR
      TempExcelBuf@1000000003 : TEMPORARY Record 370;
      Comment@1004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Comment";
      CommentText@1003 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CommentText";
      Run@1006 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Run";
      Int32Value@1020 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Int32Value";
      CommentList@1008 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CommentList";
      Comments@1005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Comments";
      SpreadsheetText@1009 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Text";
      RunProperties@1007 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.RunProperties";
      CommentsPart@1002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.WorksheetCommentsPart";
      Worksheet@1011 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Worksheet";
      Bold@1012 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Bold";
      FontSize@1013 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.FontSize";
      DoubleValue@1016 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.DoubleValue";
      Color@1018 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Color";
      RunFont@1017 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.RunFont";
      RunPropCharSet@1019 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.RunPropertyCharSet";
      CellReference@1000000002 : Text;
    BEGIN
      TempExcelBuf.VALIDATE("Column No.", ColId);
      CellReference := STRSUBSTNO('%1%2',TempExcelBuf.xlColID,RowId);

      IF ISNULL(XlWrkShtWriter.Worksheet.WorksheetPart.WorksheetCommentsPart) THEN
        AddAndInitializeCommentsPart();

      CommentsPart := XlWrkShtWriter.Worksheet.WorksheetPart.WorksheetCommentsPart;
      Comments := CommentsPart.Comments;

      IF ISNULL(Comments) THEN BEGIN
        Comments := Comments.Comments;
        CommentsPart.Comments := Comments;
      END;

      CommentList := Comments.CommentList;

      IF ISNULL(CommentList) THEN
        CommentList := XlWrkShtWriter.CreateCommentList(Comments);

      Comment := Comment.Comment;
      Comment.AuthorId := OpenXmlUInt32Value.FromUInt32(0);
      Comment.Reference := OpenXmlStringValue.StringValue(CellReference);

      CommentText := CommentText.CommentText;

      Run := Run.Run;

      RunProperties := RunProperties.RunProperties;
      Bold := Bold.Bold;

      FontSize := FontSize.FontSize;
      FontSize.Val := DoubleValue.FromDouble(9);

      Color := Color.Color;
      Color.Indexed := OpenXmlUInt32Value.FromUInt32(81);

      RunFont := RunFont.RunFont;
      RunFont.Val := OpenXmlStringValue.FromString('Tahoma');

      RunPropCharSet := RunPropCharSet.RunPropertyCharSet;
      RunPropCharSet.Val := Int32Value.FromInt32(1);

      //AppendOpenXmlElement(RunProperties,Bold);
      AppendOpenXmlElement(RunProperties,FontSize);
      AppendOpenXmlElement(RunProperties,Color);
      AppendOpenXmlElement(RunProperties,RunFont);
      AppendOpenXmlElement(RunProperties,RunPropCharSet);

      SpreadsheetText := XlWrkShtWriter.AddText(CommentValue);
      SpreadsheetText.Text := CommentValue;

      AppendOpenXmlElement(Run,RunProperties);
      AppendOpenXmlElement(Run,SpreadsheetText);

      AppendOpenXmlElement(CommentText,Run);
      Comment.CommentText := CommentText;

      XlWrkShtWriter.AppendComment(CommentList,Comment);

      CommentsPart.Comments.Save;

      CreateCommentVmlShapeXml(ColId,RowId);
    END;

    LOCAL PROCEDURE AddAndInitializeCommentsPart@1000000019();
    VAR
      WorkSheetCommentsPart@1000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.WorksheetCommentsPart";
      Comments@1002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Comments";
    BEGIN
      WorkSheetCommentsPart := XlWrkShtWriter.CreateWorksheetCommentsPart;

      StringBld := StringBld.StringBuilder;
      StringBld.Append(
        '<xml xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel">'+
          '<o:shapelayout v:ext="edit">'+
            '<o:idmap v:ext="edit" data="1"/>'+
          '</o:shapelayout>'+
          '<v:shapetype id="_x0000_t202" coordsize="21600,21600" o:spt="202"  path="m,l,21600r21600,l21600,xe">'+
            '<v:stroke joinstyle="miter"/>'+
            '<v:path gradientshapeok="t" o:connecttype="rect"/>'+
          '</v:shapetype>');

      VmlDrawingPart := XlWrkShtWriter.CreateVmlDrawingPart;

      IF ISNULL(WorkSheetCommentsPart.Comments) THEN
        WorkSheetCommentsPart.Comments := Comments.Comments;

      AddWorkSheetAuthor(WorkSheetCommentsPart.Comments, USERID);

      XlWrkShtWriter.CreateCommentList(WorkSheetCommentsPart.Comments);
    END;

    LOCAL PROCEDURE AddWorkSheetAuthor@1000000020(Comments@1003 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Comments";AuthorText@1002 : Text);
    VAR
      Author@1001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Author";
      Authors@1000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Authors";
    BEGIN
      Authors := Authors.Authors;
      AppendOpenXmlElement(Comments,Authors);
      Author := Author.Author;
      Author.Text := AuthorText;
      AppendOpenXmlElement(Authors,Author);
    END;

    LOCAL PROCEDURE FinishVmlDrawingPart@1000000021();
    VAR
      XmlTextWriter@1000000002 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlTextWriter";
      FileMode@1000000001 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.FileMode";
      Encoding@1000000000 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.Encoding";
      LegacyDrawing@1000000004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing";
      VmlPartId@1000000003 : Text;
    BEGIN
      IF ISNULL(StringBld) OR ISNULL(VmlDrawingPart) THEN
        EXIT;

      StringBld.Append('</xml>');

      XmlTextWriter := XmlTextWriter.XmlTextWriter(VmlDrawingPart.GetStream(FileMode.Create),Encoding.UTF8);
      XmlTextWriter.WriteRaw(StringBld.ToString);
      XmlTextWriter.Flush;
      XmlTextWriter.Close;

      VmlPartId := XlWrkShtWriter.Worksheet.WorksheetPart.GetIdOfPart(VmlDrawingPart);
      LegacyDrawing := LegacyDrawing.LegacyDrawing;
      LegacyDrawing.Id := OpenXmlStringValue.FromString(VmlPartId);
      AppendOpenXmlElement(XlWrkShtWriter.Worksheet.WorksheetPart.Worksheet,LegacyDrawing);

      CLEAR(StringBld);
      CLEAR(VmlDrawingPart);
    END;

    LOCAL PROCEDURE CreateCommentVmlShapeXml@1000000023(ColId@1000 : Integer;RowId@1001 : Integer);
    VAR
      Guid@1002 : GUID;
      Anchor@1003 : Text;
      CommentShape@1004 : Text;
    BEGIN
      Guid := CREATEGUID;
      Anchor := STRSUBSTNO(VmlShapeAnchorTxt,ColId,0 {RowId - 2},ColId + 2);
      CommentShape := STRSUBSTNO(CommentVmlShapeXmlTxt,Guid,Anchor,RowId - 1,ColId - 1);

      StringBld.Append(CommentShape);
    END;

    LOCAL PROCEDURE SetActiveSheet@1000000036();
    VAR
      OpenXmlWorkbook@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Workbook";
      OpenXmlBookViews@1000000003 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.BookViews";
      OpenXmlWorkbookView@1000000004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.WorkbookView";
      PartId@1000000000 : Text;
    BEGIN
      IF ActiveSheetID = 0 THEN
        ActiveSheetID := CurrSheetID;

      OpenXmlWorkbook := XlWrkBkWriter.Workbook;

      IF ISNULL(OpenXmlWorkbook.BookViews) THEN
        OpenXmlWorkbook.BookViews := OpenXmlBookViews.BookViews;

      OpenXmlBookViews := OpenXmlWorkbook.BookViews;

      IF OpenXmlBookViews.HasChildren THEN BEGIN
        OpenXmlWorkbookView := OpenXmlBookViews.FirstChild;
        OpenXmlWorkbookView.ActiveTab := OpenXmlUInt32Value.FromUInt32(ActiveSheetID - 1);
        IF ActiveSheetID > 3 THEN
          IF CurrSheetID > ActiveSheetID + 1 THEN
            OpenXmlWorkbookView.FirstSheet := OpenXmlUInt32Value.FromUInt32(ActiveSheetID - 1)
          ELSE
            OpenXmlWorkbookView.FirstSheet := OpenXmlUInt32Value.FromUInt32(ActiveSheetID - 3);
      END ELSE BEGIN
        OpenXmlWorkbookView := OpenXmlWorkbookView.WorkbookView;
        OpenXmlWorkbookView.ActiveTab := OpenXmlUInt32Value.FromUInt32(ActiveSheetID - 1);
        IF ActiveSheetID > 3 THEN
          IF CurrSheetID > ActiveSheetID + 1 THEN
            OpenXmlWorkbookView.FirstSheet := OpenXmlUInt32Value.FromUInt32(ActiveSheetID - 1)
          ELSE
            OpenXmlWorkbookView.FirstSheet := OpenXmlUInt32Value.FromUInt32(ActiveSheetID - 3);
        AppendOpenXmlElement(OpenXmlBookViews, OpenXmlWorkbookView)
      END;
      OpenXmlWorkbook.Save;
    END;

    LOCAL PROCEDURE AddDefinedName@1000000043(Name@1000000000 : Text;Scope@1000000001 : 'Workbook,CurrentSheet';Range@1000000002 : Text);
    VAR
      OpenXmlDefinedNames@1000000005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.DefinedNames";
      OpenXmlDefinedName@1000000004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.DefinedName";
    BEGIN
      OpenXmlDefinedNames := XlWrkBkWriter.Workbook.DefinedNames;
      IF ISNULL(OpenXmlDefinedNames) THEN BEGIN
        XlWrkShtWriter.AddRange(Name,Range);
        IF (CurrSheetID = 0) AND (Scope = Scope::CurrentSheet) THEN
          EXIT;
        OpenXmlDefinedName := XlWrkBkWriter.Workbook.DefinedNames.LastChild;
        IF Scope = Scope::Workbook THEN
          OpenXmlDefinedName.RemoveAttribute('LocalSheetId','')
        ELSE
          OpenXmlDefinedName.LocalSheetId := OpenXmlUInt32Value.FromUInt32(CurrSheetID);
      END ELSE BEGIN
        OpenXmlDefinedName := OpenXmlDefinedName.DefinedName;
        OpenXmlDefinedName.Name := OpenXmlStringValue.StringValue(Name);
        OpenXmlDefinedName.Text := STRSUBSTNO('''%1''!%2',XlWrkShtWriter.Name, Range);
        IF Scope = Scope::CurrentSheet THEN
          OpenXmlDefinedName.LocalSheetId := OpenXmlUInt32Value.FromUInt32(CurrSheetID);
        AppendOpenXmlElement(OpenXmlDefinedNames, OpenXmlDefinedName);
      END;
      XlWrkBkWriter.Workbook.Save;
    END;

    PROCEDURE AddPivotTableSheet@1000000049(SheetName@1000000000 : Text;SourceSheetName@1000000001 : Text;SourceRange@1000000002 : Text);
    VAR
      OpenXmlWorkSheetPart@1000000015 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.WorksheetPart";
    BEGIN
      AddNewSheet(SheetName);
      WritePageSetup;

      // 1. Add PivotTablePart to Sheet1 WorksheetPart
      OpenXmlWorkSheetPart := XlWrkShtWriter.Worksheet.WorksheetPart;
      AddNewPart(OpenXmlWorkSheetPart, PivotTablePart);
      InitPivotTablePart();

      // 2. Add PivotTableCacheDefinitionPart to PivotTablePart
      InitPivotTableCacheDefinitionPart(SourceSheetName, SourceRange);
    END;

    LOCAL PROCEDURE InitPivotTablePart@1000000060();
    VAR
      OpenXmlPivotTblDefinition@1000000004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinition";
      OpenXmlPivotTblDefExtList@1000000003 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinitionExtensionList";
      OpenXmlLocation@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Location";
      OpenXmlPivotFields@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotFields";
      OpenXmlPivotField@1000000006 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotField";
      OpenXmlPivotTableStyle@1000000012 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotTableStyle";
      OpenXmlElement@1000000009 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlElement";
      OpenXmlByteValue@1000000011 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.ByteValue";
    BEGIN
      OpenXmlPivotTblDefinition := OpenXmlPivotTblDefinition.PivotTableDefinition;
      OpenXmlPivotTblDefinition.Name := OpenXmlStringValue.FromString('PivotTable1');
      OpenXmlPivotTblDefinition.CacheId := OpenXmlUInt32Value.FromUInt32(10); // 2 (UInt32Value)2U;
      OpenXmlPivotTblDefinition.ApplyFontFormats := OpenXmlBoolValue.BooleanValue(FALSE);
      OpenXmlPivotTblDefinition.ApplyBorderFormats := OpenXmlBoolValue.BooleanValue(FALSE);
      OpenXmlPivotTblDefinition.ApplyFontFormats := OpenXmlBoolValue.BooleanValue(FALSE);
      OpenXmlPivotTblDefinition.ApplyPatternFormats := OpenXmlBoolValue.BooleanValue(FALSE);
      OpenXmlPivotTblDefinition.ApplyAlignmentFormats := OpenXmlBoolValue.BooleanValue(FALSE);
      OpenXmlPivotTblDefinition.ApplyWidthHeightFormats := OpenXmlBoolValue.BooleanValue(TRUE);
      OpenXmlPivotTblDefinition.DataCaption := OpenXmlStringValue.FromString('Values');
      OpenXmlPivotTblDefinition.UpdatedVersion := OpenXmlByteValue.FromByte(4);
      OpenXmlPivotTblDefinition.MinRefreshableVersion := OpenXmlByteValue.FromByte(3);
      OpenXmlPivotTblDefinition.UseAutoFormatting := OpenXmlBoolValue.BooleanValue(TRUE);
      OpenXmlPivotTblDefinition.ItemPrintTitles := OpenXmlBoolValue.BooleanValue(TRUE);
      OpenXmlPivotTblDefinition.CreatedVersion := OpenXmlByteValue.FromByte(4);
      OpenXmlPivotTblDefinition.Indent := OpenXmlUInt32Value.FromUInt32(0);
      OpenXmlPivotTblDefinition.Outline := OpenXmlBoolValue.BooleanValue(TRUE);
      OpenXmlPivotTblDefinition.OutlineData := OpenXmlBoolValue.BooleanValue(TRUE);
      OpenXmlPivotTblDefinition.MultipleFieldFilters := OpenXmlBoolValue.BooleanValue(FALSE);

      OpenXmlLocation := OpenXmlLocation.Location;
      OpenXmlLocation.Reference := OpenXmlStringValue.FromString('A1:C18');
      OpenXmlLocation.FirstHeaderRow := OpenXmlUInt32Value.FromUInt32(1);
      OpenXmlLocation.FirstDataRow := OpenXmlUInt32Value.FromUInt32(1);
      OpenXmlLocation.FirstDataColumn := OpenXmlUInt32Value.FromUInt32(0);
      AppendOpenXmlElement(OpenXmlPivotTblDefinition, OpenXmlLocation);

      OpenXmlPivotFields := OpenXmlPivotFields.PivotFields;
      OpenXmlPivotFields.Count := OpenXmlUInt32Value.FromUInt32(0);
      AppendOpenXmlElement(OpenXmlPivotTblDefinition, OpenXmlPivotFields);

      OpenXmlPivotTableStyle := OpenXmlPivotTableStyle.PivotTableStyle;
      OpenXmlPivotTableStyle.Name := OpenXmlStringValue.FromString('PivotStyleLight16'); //'PivotStyleMedium9'
      OpenXmlPivotTableStyle.ShowRowHeaders := OpenXmlBoolValue.BooleanValue(TRUE);
      OpenXmlPivotTableStyle.ShowColumnHeaders := OpenXmlBoolValue.BooleanValue(TRUE);
      OpenXmlPivotTableStyle.ShowRowStripes := OpenXmlBoolValue.BooleanValue(FALSE);
      OpenXmlPivotTableStyle.ShowColumnStripes := OpenXmlBoolValue.BooleanValue(FALSE);
      OpenXmlPivotTableStyle.ShowLastColumn := OpenXmlBoolValue.BooleanValue(TRUE);
      AppendOpenXmlElement(OpenXmlPivotTblDefinition, OpenXmlPivotTableStyle);

      OpenXmlPivotTblDefExtList := OpenXmlPivotTblDefExtList.PivotTableDefinitionExtensionList;
      AppendOpenXmlElement(OpenXmlPivotTblDefinition, OpenXmlPivotTblDefExtList);

      PivotTablePart.PivotTableDefinition := OpenXmlPivotTblDefinition;
    END;

    LOCAL PROCEDURE InitPivotTableCacheDefinitionPart@1000000063(SourceSheetName@1000000009 : Text;SourceRange@1000000010 : Text);
    VAR
      OpenXmlPivotTblCacheDefPart@1000000024 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.PivotTableCacheDefinitionPart";
      OpenXmlWorkbookPart@1000000021 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.WorkbookPart";
      OpenXmlPivotTblCacheRecsPart@1000000020 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.PivotTableCacheRecordsPart";
      OpenXmlPivotCacheDefinition@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinition";
      OpenXmlPivotCacheDefinitionExtList@1000000016 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinitionExtensionList";
      OpenXmlCacheSource@1000000006 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CacheSource";
      OpenXmlWorksheetSource@1000000008 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.WorksheetSource";
      OpenXmlPivotCaches@1000000023 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotCaches";
      OpenXmlPivotCache@1000000022 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotCache";
      OpenXmlByteValue@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.ByteValue";
      OpenXmlDoubleValue@1000000014 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.DoubleValue";
      OpenXmlAttribute@1000000017 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlAttribute";
      DecimalDate@1000000011 : Decimal;
    BEGIN
      DecimalDate := TODAY - DMY2DATE(1,1,1900) + 2 + (TIME-000000T)/(235959T-000000T);

      AddNewPart(PivotTablePart, OpenXmlPivotTblCacheDefPart);
      OpenXmlPivotTblCacheDefPart.PivotCacheDefinition := OpenXmlPivotCacheDefinition.PivotCacheDefinition;
      OpenXmlPivotCacheDefinition := OpenXmlPivotTblCacheDefPart.PivotCacheDefinition;

      //OpenXmlPivotCacheDefinition := OpenXmlPivotCacheDefinition.PivotCacheDefinition;
      OpenXmlPivotCacheDefinition.Id := OpenXmlStringValue.FromString('rId1');
      OpenXmlPivotCacheDefinition.RefreshedBy := OpenXmlStringValue.FromString(USERID);
      OpenXmlPivotCacheDefinition.RefreshedDate := OpenXmlDoubleValue.FromDouble(DecimalDate);
      OpenXmlPivotCacheDefinition.CreatedVersion := OpenXmlByteValue.FromByte(4);
      OpenXmlPivotCacheDefinition.RefreshedVersion := OpenXmlByteValue.FromByte(4);
      OpenXmlPivotCacheDefinition.MinRefreshableVersion := OpenXmlByteValue.FromByte(3);
      OpenXmlPivotCacheDefinition.RecordCount := OpenXmlUInt32Value.FromUInt32(0); // (UInt32Value)3U };
      OpenXmlPivotCacheDefinition.SaveData := OpenXmlBoolValue.BooleanValue(FALSE);
      OpenXmlPivotCacheDefinition.RefreshOnLoad := OpenXmlBoolValue.BooleanValue(TRUE);

      OpenXmlCacheSource := OpenXmlCacheSource.CacheSource;
      OpenXmlCacheSource.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('type','','worksheet'));
      AppendOpenXmlElement(OpenXmlPivotCacheDefinition, OpenXmlCacheSource);

      OpenXmlWorksheetSource := OpenXmlWorksheetSource.WorksheetSource;
      OpenXmlWorksheetSource.Reference := OpenXmlStringValue.FromString(SourceRange);
      OpenXmlWorksheetSource.Sheet := OpenXmlStringValue.FromString(SourceSheetName);
      AppendOpenXmlElement(OpenXmlCacheSource, OpenXmlWorksheetSource);

      InitPivotTableFields(SourceSheetName,SourceRange);

      OpenXmlPivotCacheDefinition.PivotCacheDefinitionExtensionList := OpenXmlPivotCacheDefinitionExtList.PivotCacheDefinitionExtensionList;

      // 3. Add PivotTableCacheDefinitionPart to PivotTableCacheDefinitionPart
      AddNewPart(OpenXmlPivotTblCacheDefPart, OpenXmlPivotTblCacheRecsPart);
      InitPivotTableCacheRecordsPart(OpenXmlPivotTblCacheRecsPart);

      // 4. workbookPart1.AddPart(pivotTableCacheDefinitionPart1, "rId4");
      OpenXmlWorkbookPart := XlWrkBkWriter.Workbook.WorkbookPart;
      AddPart(OpenXmlWorkbookPart,OpenXmlPivotTblCacheDefPart);

      IF ISNULL(XlWrkBkWriter.Workbook.PivotCaches) THEN
        XlWrkBkWriter.Workbook.PivotCaches := OpenXmlPivotCaches.PivotCaches();
      OpenXmlPivotCaches := XlWrkBkWriter.Workbook.PivotCaches;

      OpenXmlPivotCache := OpenXmlPivotCache.PivotCache();
      OpenXmlPivotCache.CacheId := PivotTablePart.PivotTableDefinition.CacheId; // OpenXmlUInt32Value.FromUInt32(10);
      OpenXmlPivotCache.Id := OpenXmlStringValue.StringValue(OpenXmlWorkbookPart.GetIdOfPart(OpenXmlPivotTblCacheDefPart));
      AppendOpenXmlElement(OpenXmlPivotCaches, OpenXmlPivotCache);
    END;

    LOCAL PROCEDURE InitPivotTableFields@1000000062(SourceSheetName@1000000003 : Text;SourceRange@1000000002 : Text);
    VAR
      xlBufferSource@1000000004 : Record 50000;
      OpenXmlPivotFields@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotFields";
      OpenXmlPivotField@1000000008 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotField";
      OpenXmlCacheFields@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CacheFields";
      OpenXmlCacheField@1000000007 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CacheField";
      OpenXmlSharedItems@1000000006 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.SharedItems";
      OpenXmlNumberItem@1000000005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.NumberItem";
      OpenXmlByteValue@1000000010 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.ByteValue";
      OpenXmlDoubleValue@1000000009 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.DoubleValue";
    BEGIN
      OpenXmlPivotFields := PivotTablePart.PivotTableDefinition.PivotFields;

      OpenXmlCacheFields := OpenXmlCacheFields.CacheFields;

      ReadSourceSheet(SourceSheetName,SourceRange,TRUE, xlBufferSource);
      xlBufferSource.RESET;
      IF xlBufferSource.FINDSET THEN
        REPEAT
          OpenXmlPivotField := OpenXmlPivotField.PivotField();
          OpenXmlPivotField.ShowAll := OpenXmlBoolValue.BooleanValue(FALSE);
          AppendOpenXmlElement(OpenXmlPivotFields, OpenXmlPivotField);

          OpenXmlCacheField := OpenXmlCacheField.CacheField;
          OpenXmlCacheField.Name := OpenXmlStringValue.FromString(xlBufferSource."Cell Value as Text");
          OpenXmlCacheField.NumberFormatId := OpenXmlUInt32Value.FromUInt32(0);
          OpenXmlCacheField.SharedItems := OpenXmlSharedItems.SharedItems;
          AppendOpenXmlElement(OpenXmlCacheFields, OpenXmlCacheField);
        UNTIL xlBufferSource.NEXT = 0;

      OpenXmlPivotFields.Count := OpenXmlUInt32Value.FromUInt32(OpenXmlPivotFields.ChildElements.Count);
      OpenXmlCacheFields.Count := OpenXmlUInt32Value.FromUInt32(OpenXmlCacheFields.ChildElements.Count);
      AppendOpenXmlElement(PivotTablePart.PivotTableCacheDefinitionPart.PivotCacheDefinition, OpenXmlCacheFields);
    END;

    LOCAL PROCEDURE InitPivotTableCacheRecordsPart@1000000064(VAR OpenXmlPivotTblCacheRecsPart@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.PivotTableCacheRecordsPart");
    VAR
      OpenXmlPivotCacheRecords@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotCacheRecords";
      OpenXmlPivotCacheRecord@1000000003 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotCacheRecord";
      OpenXmlFieldItem@1000000004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.FieldItem";
      OpenXmlNumberItem@1000000005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.NumberItem";
    BEGIN
      OpenXmlPivotCacheRecords := OpenXmlPivotCacheRecords.PivotCacheRecords;
      OpenXmlPivotCacheRecords.Count := OpenXmlUInt32Value.FromUInt32(0);
      OpenXmlPivotTblCacheRecsPart.PivotCacheRecords := OpenXmlPivotCacheRecords;

      {
      OpenXmlPivotCacheRecord := OpenXmlPivotCacheRecord.PivotCacheRecord;
      OpenXmlFieldItem := OpenXmlFieldItem.FieldItem;
      WrkShtHelper.AppendElementToOpenXmlElement(OpenXmlPivotCacheRecord,OpenXmlFieldItem);
      OpenXmlFieldItem := OpenXmlFieldItem.FieldItem;
      WrkShtHelper.AppendElementToOpenXmlElement(OpenXmlPivotCacheRecord,OpenXmlFieldItem);
      OpenXmlFieldItem := OpenXmlFieldItem.FieldItem;
      WrkShtHelper.AppendElementToOpenXmlElement(OpenXmlPivotCacheRecord,OpenXmlFieldItem);
      OpenXmlFieldItem := OpenXmlFieldItem.FieldItem;
      WrkShtHelper.AppendElementToOpenXmlElement(OpenXmlPivotCacheRecord,OpenXmlFieldItem);
      WrkShtHelper.AppendElementToOpenXmlElement(OpenXmlPivotCacheRecords,OpenXmlPivotCacheRecord);
      }
    END;

    PROCEDURE AddPivotTableField@1000000066(PivotFieldName@1000000000 : Text;Axis@1000000002 : 'None,axisRow,axisCol,axisPage,axisValues';DataFieldSubtotal@1101495002 : ' ,sum,count,average,max,min,product,countNums,stdDev,stdDevp,var,varp');
    VAR
      OpenXmlPivotTblDefinition@1000000004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinition";
      OpenXmlPivotFields@1000000011 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotFields";
      OpenXmlCacheFields@1000000010 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CacheFields";
      OpenXmlPivotField@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PivotField";
      OpenXmlCacheField@1000000005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CacheField";
      PageFields@1101495003 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PageFields";
      PageField@1101495004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.PageField";
      RowFields@1000000017 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.RowFields";
      ColumnFields@1000000020 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.ColumnFields";
      DataFields@1101495000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.DataFields";
      DataField@1101495001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.DataField";
      Field@1000000018 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Field";
      RowItems@1000000014 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.RowItems";
      RowItem@1000000015 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.RowItem";
      Items@1101495005 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Items";
      Item@1101495006 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Item";
      MemberPropertyIndex@1000000016 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex";
      ColumnItems@1000000013 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.ColumnItems";
      OpenXmlInt32Value@1000000019 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Int32Value";
      OpenXmlAttribute@1000000006 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlAttribute";
      IsDataField@1000000003 : Boolean;
      FieldID@1000000012 : Integer;
    BEGIN
      IF PivotFieldName = '' THEN
        EXIT;

      IF Axis = Axis::axisValues THEN BEGIN
        IF DataFieldSubtotal = DataFieldSubtotal::" " THEN
          ERROR(NoSubtotalFuncErr, PivotFieldName);
        IsDataField := TRUE;
        Axis := Axis::None
      END;

      OpenXmlPivotTblDefinition := PivotTablePart.PivotTableDefinition;
      OpenXmlPivotFields := OpenXmlPivotTblDefinition.PivotFields;
      OpenXmlCacheFields := PivotTablePart.PivotTableCacheDefinitionPart.PivotCacheDefinition.CacheFields;

      FindPivotTableField(PivotFieldName,OpenXmlCacheFields,OpenXmlCacheField,FieldID);

      OpenXmlPivotField := OpenXmlPivotFields.ChildElements.Item(FieldID);
      IF Axis <> Axis::None THEN BEGIN
        OpenXmlPivotField.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('axis','',FORMAT(Axis)));
        IF Axis <> Axis::axisPage THEN
          OpenXmlPivotField.DefaultSubtotal := OpenXmlBoolValue.BooleanValue(FALSE);
      END;
      IF IsDataField THEN
        OpenXmlPivotField.DataField := OpenXmlBoolValue.FromBoolean(TRUE);


      IF ISNULL(OpenXmlPivotTblDefinition.RowItems) THEN BEGIN
        OpenXmlPivotTblDefinition.RowItems := RowItems.RowItems;
        RowItems := OpenXmlPivotTblDefinition.RowItems;
        RowItems.Count := OpenXmlUInt32Value.FromUInt32(1);
        RowItem := RowItem.RowItem;
        AppendOpenXmlElement(RowItems, RowItem);
      END ELSE
        RowItems := OpenXmlPivotTblDefinition.RowItems;


      IF ISNULL(OpenXmlPivotTblDefinition.ColumnItems) THEN BEGIN
        OpenXmlPivotTblDefinition.ColumnItems := ColumnItems.ColumnItems;
        ColumnItems := OpenXmlPivotTblDefinition.ColumnItems;
        ColumnItems.Count := OpenXmlUInt32Value.FromUInt32(1);
        RowItem := RowItem.RowItem;
        AppendOpenXmlElement(ColumnItems, RowItem);
      END ELSE
        ColumnItems := OpenXmlPivotTblDefinition.ColumnItems;


      IF Axis = Axis::axisRow THEN BEGIN
        IF ISNULL(OpenXmlPivotTblDefinition.RowFields) THEN
          OpenXmlPivotTblDefinition.RowFields := RowFields.RowFields;
        RowFields := OpenXmlPivotTblDefinition.RowFields;
        Field := Field.Field;
        Field.Index := OpenXmlInt32Value.FromInt32(FieldID);
        AppendOpenXmlElement(RowFields, Field);
        RowFields.Count := OpenXmlUInt32Value.FromUInt32(RowFields.ChildElements.Count);

        IF RowItems.ChildElements.Count = 1 THEN BEGIN
          RowItem := RowItems.ChildElements.Item(0);
          MemberPropertyIndex := MemberPropertyIndex.MemberPropertyIndex;
          AppendOpenXmlElement(RowItem, MemberPropertyIndex);

          RowItem := RowItem.RowItem;
          RowItem.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('t','','grand'));
          MemberPropertyIndex := MemberPropertyIndex.MemberPropertyIndex;
          AppendOpenXmlElement(RowItem, MemberPropertyIndex);
          AppendOpenXmlElement(RowItems, RowItem);
          RowItems.Count := OpenXmlUInt32Value.FromUInt32(2);
        END;
      END;

      IF Axis = Axis::axisCol THEN BEGIN
        IF ISNULL(OpenXmlPivotTblDefinition.ColumnFields) THEN
          OpenXmlPivotTblDefinition.ColumnFields := ColumnFields.ColumnFields;
        ColumnFields := OpenXmlPivotTblDefinition.ColumnFields;
        Field := Field.Field;
        Field.Index := OpenXmlInt32Value.FromInt32(FieldID);
        AppendOpenXmlElement(ColumnFields, Field);
        ColumnFields.Count := OpenXmlUInt32Value.FromUInt32(ColumnFields.ChildElements.Count);

        IF ColumnItems.ChildElements.Count = 1 THEN BEGIN
          RowItem := ColumnItems.ChildElements.Item(0);
          MemberPropertyIndex := MemberPropertyIndex.MemberPropertyIndex;
          AppendOpenXmlElement(RowItem, MemberPropertyIndex);

          RowItem := RowItem.RowItem;
          RowItem.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('t','','grand'));
          MemberPropertyIndex := MemberPropertyIndex.MemberPropertyIndex;
          AppendOpenXmlElement(RowItem, MemberPropertyIndex);
          AppendOpenXmlElement(ColumnItems, RowItem);
          ColumnItems.Count := OpenXmlUInt32Value.FromUInt32(2);
        END;
      END;

      IF Axis = Axis::axisPage THEN BEGIN
        IF ISNULL(OpenXmlPivotTblDefinition.PageFields) THEN BEGIN
          OpenXmlPivotTblDefinition.Location.RowPageCount := OpenXmlUInt32Value.FromUInt32(1);
          OpenXmlPivotTblDefinition.Location.ColumnsPerPage := OpenXmlUInt32Value.FromUInt32(1);
          OpenXmlPivotTblDefinition.Location.Reference := OpenXmlStringValue.FromString('A3:B5');

          OpenXmlPivotTblDefinition.PageFields := PageFields.PageFields;
        END;

        PageFields := OpenXmlPivotTblDefinition.PageFields;
        PageField := PageField.PageField;
        PageField.Field := OpenXmlInt32Value.FromInt32(FieldID);
        PageField.Hierarchy := OpenXmlInt32Value.FromInt32(-1);
        AppendOpenXmlElement(PageFields, PageField);

        IF NOT OpenXmlPivotField.HasChildren THEN BEGIN
          Items := Items.Items;
          Items.Count := OpenXmlUInt32Value.FromUInt32(1);
          Item := Item.Item;
          Item.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('t','','default'));
          AppendOpenXmlElement(Items, Item);
          AppendOpenXmlElement(OpenXmlPivotField, Items);
        END;
        PageFields.Count := OpenXmlUInt32Value.FromUInt32(PageFields.ChildElements.Count);
      END;

      IF IsDataField THEN BEGIN
        IF ISNULL(OpenXmlPivotTblDefinition.DataFields) THEN
          OpenXmlPivotTblDefinition.DataFields := DataFields.DataFields;

        DataFields := OpenXmlPivotTblDefinition.DataFields;

        DataField := DataField.DataField;
        DataField.SetAttribute(OpenXmlAttribute.OpenXmlAttribute('subtotal','',FORMAT(DataFieldSubtotal)));
        DataField.Name := OpenXmlStringValue.FromString(FORMAT(DataFieldSubtotal) + ' of ' + PivotFieldName);

        DataField.Field := OpenXmlUInt32Value.FromUInt32(FieldID);
        DataField.BaseField := OpenXmlInt32Value.FromInt32(0);
        DataField.BaseItem := OpenXmlUInt32Value.FromUInt32(0);

        AppendOpenXmlElement(DataFields, DataField);
        DataFields.Count := OpenXmlUInt32Value.FromUInt32(DataFields.ChildElements.Count);
      END;

      {
      ID | Format Code
      0  | General
      1  | 0
      2  | 0.00
      3  | #,##0
      4  | #,##0.00
      9  | 0%
      10 | 0.00%
      11 | 0.00E+00
      12 | # ?/?
      13 | # ??/??
      14 | d/m/yyyy
      15 | d-mmm-yy
      16 | d-mmm
      17 | mmm-yy
      18 | h:mm tt
      19 | h:mm:ss tt
      20 | H:mm
      21 | H:mm:ss
      22 | m/d/yyyy H:mm
      37 | #,##0 ;(#,##0)
      38 | #,##0 ;[Red](#,##0)
      39 | #,##0.00;(#,##0.00)
      40 | #,##0.00;[Red](#,##0.00)
      45 | mm:ss
      46 | [h]:mm:ss
      47 | mmss.0
      48 | ##0.0E+0
      49 | @
      }
    END;

    [TryFunction]
    LOCAL PROCEDURE FindPivotTableField@1000000059(FieldName@1000000001 : Text;VAR CacheFields@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CacheFields";VAR CacheField@1000000003 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.CacheField";VAR FieldID@1000000002 : Integer);
    BEGIN
      FieldID := 0;
      FOREACH CacheField IN CacheFields DO BEGIN
        IF FORMAT(CacheField.Name) = FieldName THEN
          EXIT;

        FieldID += 1;
      END;

      ERROR(PivotFieldDoesntExistErr, FieldName);
    END;

    LOCAL PROCEDURE AppendOpenXmlElement@1000000047(ParentOpenXmlElement@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlElement";ChildOpenXmlElement@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlElement");
    VAR
      ArrOfValues@1000000002 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
    BEGIN
      ArrOfValues := ArrOfValues.CreateInstance(GETDOTNETTYPE(ChildOpenXmlElement), 1);
      ArrOfValues.SetValue(ChildOpenXmlElement,0);

      ParentOpenXmlElement.Append(ArrOfValues);
    END;

    LOCAL PROCEDURE AddNewPart@1101495001(VAR ParentOpenXmlPart@1101495006 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.OpenXmlPart";VAR ChildOpenXmlPart@1101495002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.OpenXmlPart");
    VAR
      Method@1101495000 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Reflection.MethodInfo";
      GenericMethod@1101495001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Reflection.MethodInfo";
      Type@1101495005 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Type";
      Object@1101495008 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Object";
      ArrOfTypes@1101495003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      ArrOfValues@1101495007 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
    BEGIN
      Type := GETDOTNETTYPE(ParentOpenXmlPart);
      ArrOfTypes := ArrOfTypes.CreateInstance(GETDOTNETTYPE(Type), 0);
      Method := Type.GetMethod('AddNewPart', ArrOfTypes);

      ArrOfTypes := ArrOfTypes.CreateInstance(GETDOTNETTYPE(Type),1);
      ArrOfTypes.SetValue(GETDOTNETTYPE(ChildOpenXmlPart),0);

      GenericMethod := Method.MakeGenericMethod(ArrOfTypes);

      ArrOfValues := ArrOfValues.CreateInstance(GETDOTNETTYPE(Object),0);
      ChildOpenXmlPart := GenericMethod.Invoke(ParentOpenXmlPart, ArrOfValues);
    END;

    LOCAL PROCEDURE AddPart@1000000053(VAR ParentOpenXmlPart@1000000001 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.OpenXmlPart";VAR ChildOpenXmlPart@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Packaging.OpenXmlPart");
    VAR
      Type@1000000010 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Type";
      ArrOfTypes@1000000009 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      ArrOfValues@1000000008 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      Method@1000000007 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Reflection.MethodInfo";
      GenericMethod@1000000004 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Reflection.MethodInfo";
      Object@1000000003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Object";
    BEGIN
      IF NOT FindMethod(GETDOTNETTYPE(ParentOpenXmlPart),'AddPart',1, Method) THEN
        EXIT;

      ArrOfTypes := ArrOfTypes.CreateInstance(GETDOTNETTYPE(Type),1);
      ArrOfTypes.SetValue(GETDOTNETTYPE(ChildOpenXmlPart),0);

      GenericMethod := Method.MakeGenericMethod(ArrOfTypes);

      ArrOfValues := ArrOfValues.CreateInstance(GETDOTNETTYPE(Object),1);
      ArrOfValues.SetValue(ChildOpenXmlPart,0);

      GenericMethod.Invoke(ParentOpenXmlPart,ArrOfValues);
    END;

    LOCAL PROCEDURE FindMethod@1101495003(Type@1101495004 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Type";MethodName@1101495005 : Text;ParamsCount@1101495006 : Integer;VAR FoundMethod@1101495002 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Reflection.MethodInfo") : Boolean;
    VAR
      Method@1101495003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Reflection.MethodInfo";
      ParamInfo@1101495001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Reflection.ParameterInfo";
      MethodFound@1101495000 : Boolean;
    BEGIN
      FOREACH Method IN Type.GetMethods() DO
        IF Method.Name = MethodName THEN
          IF Method.GetParameters.Length = ParamsCount THEN BEGIN
            FoundMethod := Method;
            EXIT(TRUE);
          END;

      EXIT(FALSE);
    END;

    PROCEDURE CalcFormulasAndSave@1000000044(WithQuit@1000000000 : Boolean) FileNameClient : Text;
    VAR
      FileNameClientTemp@1000000001 : Text;
      Directory@1000000003 : Text;
    BEGIN
      CloseBook;

      IF OpenUsingDocumentService('') THEN
        EXIT;

      IF NOT PreOpenExcel THEN
        EXIT;

      FileNameClientTemp := FileManagement.DownloadTempFile(FileNameServer);
      IF ERASE(FileNameServer) THEN;

      IF ClientPath = '' THEN BEGIN
        Directory := FileManagement.GetDirectoryName(FileNameClientTemp);
        Directory := FileManagement.CombinePath(Directory,FORMAT(CREATEGUID));
        FileManagement.CreateClientDirectory(Directory);
        FileNameClient := FileManagement.CombinePath(Directory,GetFriendlyFilename);
      END ELSE
        FileNameClient := FileManagement.CombinePath(ClientPath,GetFriendlyFilename);

      IF FileManagement.ClientFileExists(FileNameClient) THEN
        FileManagement.DeleteClientFile(FileNameClient);

      XlWrkBk := XlHelper.CallOpen(XlApp,FileNameClientTemp);
      PostOpenExcel;
      XlHelper.CallSaveAs(XlWrkBk,FileNameClient);

      FileManagement.DeleteClientFile(FileNameClientTemp);

      IF WithQuit THEN BEGIN
        CloseBook;
        QuitExcel;
      END;
    END;

    PROCEDURE CalcFormulasAndOpen@1000000045();
    VAR
      FileNameClient@1000 : Text;
    BEGIN
      FileNameClient := CalcFormulasAndSave(FALSE);
      XlWrkBk := XlHelper.CallOpen(XlApp,FileNameClient);
    END;

    LOCAL PROCEDURE ReadSourceSheet@1000000058(SheetName@1000000001 : Text;RangeAddress@1000000000 : Text;OnlyHeaderRow@1000000005 : Boolean;VAR xlBufferRead@1000000015 : Record 50000);
    VAR
      Reader@1000000002 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.OpenXmlReader";
      Row@1000000007 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Row";
      Cell@1000000004 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Cell";
      Text@1000000003 : Text;
      Type@1000000006 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Type";
      FromRowNo@1000000012 : Integer;
      FromColNo@1000000011 : Integer;
      ToRowNo@1000000010 : Integer;
      ToColNo@1000000009 : Integer;
      RowIndex@1000000013 : Integer;
      ColIndex@1000000014 : Integer;
    BEGIN
      IF NOT XlWrkBkWriter.HasWorksheet(SheetName) THEN
        ERROR(Text004,SheetName);

      GetIntegerRange(RangeAddress,FromRowNo,FromColNo,ToRowNo,ToColNo);

      IF FromRowNo = 0 THEN
        FromRowNo := 1;

      IF OnlyHeaderRow THEN
        ToRowNo := FromRowNo;

      IF ToRowNo = 0 THEN
        ToRowNo := 1048576; // Maximum number of rows in Excel

      xlBufferRead.DELETEALL;

      Reader := Reader.Create(XlWrkBkWriter.GetWorksheetByName(SheetName).Worksheet);
      WHILE Reader.Read() DO BEGIN
        Type := Reader.ElementType;
        IF Type.Name = 'Row' THEN BEGIN
           Row := Reader.LoadCurrentElement;
           EVALUATE(RowIndex,FORMAT(Row.RowIndex));
           IF RowIndex IN [FromRowNo..ToRowNo] THEN
             FOREACH Cell IN Row.ChildElements DO BEGIN
               ColIndex := GetColumnInt(DELCHR(FORMAT(Cell.CellReference),'=',FORMAT(RowIndex)));
               Text := GetCellValue(Cell);
               IF Text <> '' THEN BEGIN
                 xlBufferRead.VALIDATE("Row No.",RowIndex);
                 xlBufferRead.VALIDATE("Column No.",ColIndex);
                 xlBufferRead."Cell Type" := xlBufferRead."Cell Type"::Text;
                 xlBufferRead."Cell Value as Text" := Text;
                 IF NOT ISNULL(Cell.DataType) THEN
                   CASE FORMAT(Cell.DataType.Value) OF
                     'Number':
                       xlBufferRead."Cell Type" := xlBufferRead."Cell Type"::Number;
                     'Date':
                       xlBufferRead."Cell Type" := xlBufferRead."Cell Type"::Date;
                     'Boolean',
                     'Error',
                     'InlineString',
                     'SharedString',
                     'String':
                       xlBufferRead."Cell Type" := xlBufferRead."Cell Type"::Text;
                   END;
                 xlBufferRead.INSERT;
               END;
             END;
           IF RowIndex >= ToRowNo THEN
             EXIT;
        END;
      END;
    END;

    LOCAL PROCEDURE GetCellValue@1000000057(Cell@1000000000 : DotNet "'DocumentFormat.OpenXml, Version=2.5.5631.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35'.DocumentFormat.OpenXml.Spreadsheet.Cell") : Text;
    VAR
      Value@1000000002 : Text;
      IntValue@1000000003 : Integer;
    BEGIN
      IF NOT ISNULL(Cell.CellValue) THEN
        Value := Cell.CellValue.InnerText;

      IF NOT ISNULL(Cell.DataType) THEN BEGIN

        IF FORMAT(Cell.DataType.Value) = 'InlineString' THEN
          EXIT(FORMAT(Cell.InlineString.InnerText));

        IF FORMAT(Cell.DataType.Value) = 'SharedString' THEN
          IF EVALUATE(IntValue, Value) THEN
            EXIT(XlWrkBkWriter.Workbook.WorkbookPart.SharedStringTablePart.SharedStringTable.ChildElements.GetItem(IntValue).InnerText);
      END;
      EXIT(Value);
    END;
    PROCEDURE SetPaperSize@50(NewPaperSize@1000 : Integer);
    BEGIN
      PaperSize := NewPaperSize;
      // (https://learn.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pagesetup?view=openxml-2.8.1#:~:text=paperSize%20(Paper%20Size) )
    END;

    EVENT XmlWrkShtDoc@1000000000::NodeInserting@94(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlWrkShtDoc@1000000000::NodeInserted@95(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlWrkShtDoc@1000000000::NodeRemoving@96(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlWrkShtDoc@1000000000::NodeRemoved@97(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlWrkShtDoc@1000000000::NodeChanging@98(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlWrkShtDoc@1000000000::NodeChanged@99(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlCellFormatsDoc@1000000002::NodeInserting@94(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlCellFormatsDoc@1000000002::NodeInserted@95(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlCellFormatsDoc@1000000002::NodeRemoving@96(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlCellFormatsDoc@1000000002::NodeRemoved@97(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlCellFormatsDoc@1000000002::NodeChanging@98(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    EVENT XmlCellFormatsDoc@1000000002::NodeChanged@99(sender@1000000001 : Variant;e@1000000000 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlNodeChangedEventArgs");
    BEGIN
    END;

    BEGIN
    END.
  }
}

